### 88. Merge Sorted Array
```python
class Solution:
    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:
        """
        Do not return anything, modify nums1 in-place instead.
        """
        # 两个数列各一指针
        i = m - 1
        j = n - 1
        # 用于写入的辅助指针
        k = m + n - 1

        while i >= 0 and j >= 0:
            if nums1[i] > nums2[j]:
                nums1[k] = nums1[i]
                i -= 1
            else:
                nums1[k] = nums2[j]
                j -= 1
            k -= 1
        
        # 如果nums1的有效长度短，nums2剩下的部分就直接覆盖前面那部分
        while j>= 0:
            nums1[k] = nums2[j]
            j -= 1
            k -= 1

        # 如果nums2的有效长度短，那到这已经完美不需要处理了
        
```

```python
# 暴力解法
class Solution:
    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:
        """
        Do not return anything, modify nums1 in-place instead.
        """
        # 将 nums2 的元素直接复制到 nums1 的后半部分
        for i in range(n):
            nums1[m + i] = nums2[i]
        
        # 对整个 nums1 进行排序
        nums1.sort()
```

```cpp
//暴力解法
class Solution {
public:
    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {
        for (int i = 0; i < n; ++i) {
            nums1[i + m] = nums2[i];
        }
        std::sort(nums1.begin(), nums1.end()); //标准库函数，使用半开区间概念
    }
};

```

### 27. Remove Element
```python
class Solution:
    def removeElement(self, nums: List[int], val: int) -> int:
        k=0    # 慢指针
        # 很简单，就是利用双指针，有命中的时候辅助指针不自增，
        # 等着循环指针前移后，利用后面的前移步骤洗掉这个命中位置的元素
        for i in range(len(nums)):
            if nums[i] != val:
                if i != k:
                # 例：如果本身就是1357000，匹配2，那就没必要移动
                    nums[k] = nums[i]
                    # 把原本在后面的元素移到k的位置
                k += 1
        return k
```
```python
class Solution:
    def removeElement(self, nums: List[int], val: int) -> int:
        i = 0
        j = len(nums) - 1
        # 在某些情况下（例如数组中有很多等于 val 的元素）可能会更快，
        # 因为直接跳过了这些元素，而不需要逐一检查。
        # 但顺序会乱，因为尾部的元素被移动到了前面
        while i <= j:
            if nums[i] == val:
                nums[i] = nums[j]  # 用尾部元素替换
                j -= 1  # 尾部指针左移
            else:
                i += 1  # 头部指针右移
        
        return i
```
```python
class Solution:
    def removeElement(self, nums: List[int], val: int) -> int:
        # 使用列表推导式生成新数组
        filtered_nums = [x for x in nums if x != val]
        # 将结果写回原数组
        for i in range(len(filtered_nums)):
            nums[i] = filtered_nums[i]
        return len(filtered_nums)
```

```cpp
class Solution {
public:
    int removeElement(vector<int>& nums, int val) {
        std ::vector<int> temp; //temp arry
        for (int num : nums){
            if (num != val){
                temp.push_back(num);//or we can use push_front() in a std::<int> dq scenario
            }
        }
        nums = temp;
        return temp.size();
    }
};
```

### 26. Remove Duplicates from Sorted Array
```cpp
class Solution {
public:
    int removeDuplicates(vector<int>& nums) {
        if (nums.empty()) return 0; //判空

        int i = 0; //慢指针
        for (int j = 1; j < nums.size(); ++j){
            if (nums[j] != nums[i]){//若正常非重复，后面i会正常自增
                ++i;
                if (i != j){ //ij两个指针有错位时才进行赋值
                    nums[i] = nums[j]; 
                }
            }
        }
        return i + 1;
    }
};
```

```cpp
//暴力解法
class Solution {
public:
    int removeDuplicates(vector<int>& nums) {
        if(nums.empty()  )  return 0;
        
        vector<int> unique_nums;
        unique_nums.push_back(nums[0]);

        for (int i = 1; i < nums.size(); ++ i){
            if(nums[i] != unique_nums.back()){
                unique_nums.push_back(nums[i]);
            }
        }

        for (int i = 0; i < unique_nums.size(); ++i){
            nums [i] = 0;
        }

        for (int i = 0; i < unique_nums.size(); ++i){
            nums [i] = unique_nums[i];
        }

        return unique_nums.size();
    }
};

```

### 80. Remove Duplicates from Sorted Array II
```cpp
class Solution {
public:
    int removeDuplicates(vector<int>& nums) {
        if (nums.size() <= 2) return  nums.size(); //数组长度小于等于2，直接返回长度
        int i = 2; //可以理解为慢指针，初始值为2（前两个元素一定符合条件）
        for(int j = 2; j < nums.size(); ++j){//从第3个元素开始遍历
            if (nums[j] != nums[i-2]){//如果当前元素与前两个不一样，就往前挪
                                      //如果一样，就不进来，让慢指针站着
                nums[i] = nums[j];  //挪
                i += 1;
            }
        }
        return i;
    }
};
```
```cpp
//一样，一些小更改
class Solution {
public:
    int removeDuplicates(vector<int>& nums) {
        if (nums.size() <= 2) return nums.size(); // 数组长度小于等于2，直接返回长度
        
        int i = 2; // 慢指针，初始值为2（前两个元素一定符合条件）
        int n = nums.size(); // 避免重复调用 nums.size()
        
        for (int j = 2; j < n; ++j) { // 从第3个元素开始遍历
            if (nums[j] != nums[i - 2]) { // 如果当前元素与前两个不一样
                nums[i++] = nums[j]; // 直接赋值并递增慢指针
            }
        }
        return i; // 返回符合条件的元素个数
    }
};
```

```cpp
//暴力解法
class Solution {
public:
    int removeDuplicates(vector<int>& nums) {
        int size = nums.size();
        vector<int> temp;

        if (size <= 2) return size;

        temp.push_back(nums[0]);
        temp.push_back(nums[1]);

        for(int i = 2; i < size; ++i){
            if(nums[i] != temp[temp.size()-2]){
                temp.push_back(nums[i]);
            }
        }
        for(int i = 0; i < temp.size(); ++i){
            nums[i] = temp[i];
        }
        return temp.size();
    }
};

```

### 169. Majority Element
```cpp
class Solution {
public:
    int majorityElement(vector<int>& nums) {
        //用摩尔投票算法（抵消机制）
        int candidate = 0;
        int count = 0;
        for (int num : nums) {
            if （count == 0) {
                candidate = num;
            }
            count += (num == candidate) ? 1: -1;
        }
        return candidate;
        //同+异-，到0就换人，最后没被-到0的就是正确candidate
    }
};

```

```cpp
//暴力解法
class Solution {
public:
    int majorityElement(vector<int>& nums) {
        int size = nums.size();
        for(int num : nums){
            int count = 0;
            for (int other : nums){
                if(num == other){
                    ++count;
                }
            }
            if(count> size/2){
                return num;
            }
        }
        return -1;
    }
};
```

### 189. Rotate Array

<!-- 
<img width="241" alt="{82C08DFF-EE2C-44CA-BC51-9CF36696EEB6}" src="https://github.com/user-attachments/assets/9b6ed2ae-c6d6-43e3-9ee5-3b3eb28ed7bf" />
<img width="241" alt="{4F6C9CBF-38CD-47C7-AD21-0371340FCA83}" src="https://github.com/user-attachments/assets/3c15ce2a-3fa3-47ea-b8f6-0c98c425788a" />
<img width="483" alt="{55730CE6-D344-4739-8F8C-784572E7160F}" src="https://github.com/user-attachments/assets/0986152a-423b-4962-a530-7b6d028053a3" />
-->

#### 示例：
假设我们有一个数组 `nums = [1, 2, 3, 4, 5, 6]`，并且 `k = 2`。我们的目标是将数组向右旋转 2 个位置。

##### 初始数组：
```
[1, 2, 3, 4, 5, 6]
```

##### 旋转后的目标数组：
```
[5, 6, 1, 2, 3, 4]
```

#### 算法执行过程：

##### 第一步：初始化
- 数组长度 `n = 6`。
- `k = k % n = 2 % 6 = 2`。
- 定义计数器 `count = 0`，用于记录已经处理过的元素数量。
- 外层循环从 `start = 0` 开始。

##### 第二步：处理第一个环
1. **外层循环**：`start = 0`，表示从索引 `0` 开始处理。
   - `current = start = 0`，`prev = nums[0] = 1`。
   
2. **内层循环**（`do-while`）：
   - **第一次迭代**：
     - 计算下一个位置：`next = (current + k) % n = (0 + 2) % 6 = 2`。
     - 保存目标位置的值：`temp = nums[next] = nums[2] = 3`。
     - 将当前值放到目标位置：`nums[next] = prev = 1`。
     - 更新 `prev = temp = 3`。
     - 更新 `current = next = 2`。
     - 增加计数器：`count++`，现在 `count = 1`。
     
     当前数组状态：
     ```
     [1, 2, 1, 4, 5, 6]
     ```

   - **第二次迭代**：
     - 计算下一个位置：`next = (current + k) % n = (2 + 2) % 6 = 4`。
     - 保存目标位置的值：`temp = nums[next] = nums[4] = 5`。
     - 将当前值放到目标位置：`nums[next] = prev = 3`。
     - 更新 `prev = temp = 5`。
     - 更新 `current = next = 4`。
     - 增加计数器：`count++`，现在 `count = 2`。
     
     当前数组状态：
     ```
     [1, 2, 1, 4, 3, 6]
     ```

   - **第三次迭代**：
     - 计算下一个位置：`next = (current + k) % n = (4 + 2) % 6 = 0`。
     - 保存目标位置的值：`temp = nums[next] = nums[0] = 1`。
     - 将当前值放到目标位置：`nums[next] = prev = 5`。
     - 更新 `prev = temp = 1`。
     - 更新 `current = next = 0`。
     - 增加计数器：`count++`，现在 `count = 3`。
     
     当前数组状态：
     ```
     [5, 2, 1, 4, 3, 6]
     ```

   - **退出内层循环**：此时 `current == start`，即回到了起始位置 `0`，表示这个环已经处理完毕。

##### 第三步：处理第二个环
1. **外层循环**：`start = 1`，表示从索引 `1` 开始处理。
   - `current = start = 1`，`prev = nums[1] = 2`。

2. **内层循环**（`do-while`）：
   - **第一次迭代**：
     - 计算下一个位置：`next = (current + k) % n = (1 + 2) % 6 = 3`。
     - 保存目标位置的值：`temp = nums[next] = nums[3] = 4`。
     - 将当前值放到目标位置：`nums[next] = prev = 2`。
     - 更新 `prev = temp = 4`。
     - 更新 `current = next = 3`。
     - 增加计数器：`count++`，现在 `count = 4`。
     
     当前数组状态：
     ```
     [5, 2, 1, 2, 3, 6]
     ```

   - **第二次迭代**：
     - 计算下一个位置：`next = (current + k) % n = (3 + 2) % 6 = 5`。
     - 保存目标位置的值：`temp = nums[next] = nums[5] = 6`。
     - 将当前值放到目标位置：`nums[next] = prev = 4`。
     - 更新 `prev = temp = 6`。
     - 更新 `current = next = 5`。
     - 增加计数器：`count++`，现在 `count = 5`。
     
     当前数组状态：
     ```
     [5, 2, 1, 2, 3, 4]
     ```

   - **第三次迭代**：
     - 计算下一个位置：`next = (current + k) % n = (5 + 2) % 6 = 1`。
     - 保存目标位置的值：`temp = nums[next] = nums[1] = 2`。
     - 将当前值放到目标位置：`nums[next] = prev = 6`。
     - 更新 `prev = temp = 2`。
     - 更新 `current = next = 1`。
     - 增加计数器：`count++`，现在 `count = 6`。
     
     当前数组状态：
     ```
     [5, 6, 1, 2, 3, 4]
     ```

   - **退出内层循环**：此时 `current == start`，即回到了起始位置 `1`，表示这个环已经处理完毕。

##### 第四步：结束
- 此时 `count == n`，所有元素都已经被处理完毕，算法结束。

#### 最终结果：
```
[5, 6, 1, 2, 3, 4]
```

#### 总结：
在这个例子中，数组被分成了两个环：
1. 第一个环：`1 -> 3 -> 5 -> 1`。
2. 第二个环：`2 -> 4 -> 6 -> 2`。

外层循环负责确保每个环都被处理，而内层循环则在一个环内完成元素的旋转。通过这种方式，算法高效地完成了数组的旋转操作。
```cpp
class Solution {
public:
    void rotate(vector<int>& nums, int k) {
        int n = nums.size(); //
        k = k % n;
        int count = 0; //当 count 达到数组的长度 n 时，说明所有元素都已经完成了旋转。
        for (int start = 0; count < n; ++start){
            int current =start; //当前正在处理的元素的索引
            int prev =nums[start]; //当前元素的值

            do{
                int next = (current + k) % n; //计算当前元素应该移动到的目标位置。
                int temp = nums[next]; //保存目标位置的原始值。
                nums[next]=prev; //将当前元素的值放到目标位置。
                prev = temp; //更新 prev 为刚才保存的目标位置的原始值，以便下一次循环使用。
                current = next; //更新 current 为下一个要处理的索引。
                count++;
            }while(start != current); //当 current 回到起始位置 start 时，表示这个“环”内的所有元素都已经被处理完
        }
    }
};
```

```cpp
class Solution {
public:
    void rotate(vector<int>& nums, int k) {
        int n = nums.size();
        k = k % n;
        reverse(nums.begin(),nums.end());
        reverse(nums.begin(),nums.begin()+k);
        reverse(nums.begin()+k,nums.end());
    }
};
```
```cpp

//暴力
class Solution {
public:
    void rotate(vector<int>& nums, int k) {
        int size = nums.size();
        int step = k % size;
        vector<int> front_nums(step);
        vector<int> back_nums(size-step);
        for(int i=0; i<step; ++i){
            front_nums[i]=nums[size-step+i];
        }
        for(int i=0; i<size-step; ++i){
            back_nums[i]=nums[i];
        }
        for(int i=0; i<size; ++i){
            if(i<step){
                nums[i]=front_nums[i];
            }
            else{
                nums[i]=back_nums[i-step];
            }
        }
    }
};
```

### 121. Best Time to Buy and Sell Stock

```cpp
//暴力
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int size = prices.size();
        int profit = 0;
        for(int i = 0; i < size; ++i){
            int buy = prices[i];
            for(int j = i + 1; j < size; ++j){
                int sell = prices[j];
                if((sell - buy)>profit){
                    profit = sell - buy;
                }
            }
        }
        return profit;
    }
};
```
```cpp
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int buy = INT_MAX;
        int profit = 0;
        for (int price : prices){
            if (price < buy){
                buy = price;
            }
            else{
                profit = max(profit, price - buy);
            }
        }
        return profit;
    }

};

```

```cpp
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int size = prices.size();
        if (size <= 1) return 0;

        int min_price = INT_MAX;
        int profit = 0; 

        for (int i = 1; i < size; ++i) {
            min_price = min(prices[i-1],min_price);
            profit = max(prices[i] - min_price, profit);
        }

        return profit;
    }
};

```
### 122. Best Time to Buy and Sell Stock II
```cpp
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        //贪心算法
        int max_profit = 0;
        for(int i = 1; i  < prices.size(); ++i){
            if (prices[i] > prices[i-1]){
               max_profit +=  (prices[i] - prices[i-1]);
            }
        }
        return max_profit;
    }
};
```

### 55. Jump Game

```cpp
class Solution {
public:
    bool canJump(vector<int>& nums) {
        if (nums.size() == 1) {
            return true;
        }
        int max_reach = 0;
        for(int i=0;i<nums.size();++i){
            if(i > max_reach){
                return false;
            }
            max_reach = max(nums[i]+i,max_reach);
            if((max_reach>=nums.size()-1)){
                return true;
            }
        }
        return false;
    }
};
```

### 45. Jump Game II
```cpp
class Solution {
public:
    int jump(vector<int>& nums) {
        //贪心算法
        if(nums.size() == 1) return 0;
        int jumps = 0;
        int current_end = 0;
        int most_far = 0;
        for(int i = 0; i<nums.size()-1; ++i){
            most_far = max(i + nums[i],most_far);
            if(i == current_end){
                ++jumps;
                current_end = most_far;
            }
            if(current_end>=nums.size()-1){
                break;
            }
        }
        return jumps;
    }
};
```

---

#### 动态规划的核心思想

动态规划是一种通过将问题分解为子问题，并存储子问题的解来避免重复计算的方法。在本题中，动态规划的核心思想是：
- **定义状态**：用 `dp[i]` 表示从索引 `i` 到达终点所需的最小跳跃次数。
- **状态转移方程**：通过递推关系，从已知的状态推导出未知的状态。
- **初始条件**：明确一些已知的状态（如终点的状态）。
- **最终目标**：求解 `dp[0]`，即从起点到达终点的最小跳跃次数。

---

#### 代码逐步解析

##### 1. 初始化
```cpp
int n = nums.size();
vector<int> dp(n, INT_MAX);  // dp[i] 表示从索引 i 到达终点的最小跳跃次数
dp[n - 1] = 0;               // 最后一个位置无需跳跃
```

- **`dp` 数组**：
  - `dp[i]` 表示从索引 `i` 到达终点所需的最小跳跃次数。
  - 初始时，所有位置的跳跃次数都设为 `INT_MAX`，表示尚未计算。
  
- **初始条件**：
  - 终点（最后一个位置）不需要跳跃，因此 `dp[n-1] = 0`。

---

##### 2. 自底向上填充 `dp` 数组
```cpp
for (int i = n - 2; i >= 0; --i) {
    int max_step = nums[i];
    for (int step = 1; step <= max_step && i + step < n; ++step) {
        dp[i] = min(dp[i], 1 + dp[i + step]);
    }
}
```

这段代码是动态规划的核心部分，我们逐行分析：

###### (1) 外层循环
```cpp
for (int i = n - 2; i >= 0; --i)
```
- 从倒数第二个位置开始向前遍历数组。
- 因为终点的状态已经确定（`dp[n-1] = 0`），所以从 `n-2` 开始向前推导。

###### (2) 当前位置的最大跳跃步数
```cpp
int max_step = nums[i];
```
- `nums[i]` 表示从索引 `i` 出发能够跳跃的最大步数。
- 这决定了我们可以尝试的所有跳跃目标位置。

###### (3) 内层循环：尝试所有可能的跳跃目标
```cpp
for (int step = 1; step <= max_step && i + step < n; ++step) {
    dp[i] = min(dp[i], 1 + dp[i + step]);
}
```
- **内层循环的作用**：
  - 从当前位置 `i` 出发，尝试跳到 `[i+1, i+max_step]` 中的所有位置。
  - 对于每个目标位置 `i + step`，计算从 `i` 跳到 `i + step` 所需的跳跃次数。

- **状态转移方程**：
  - 如果从 `i` 跳到 `i + step`，那么总的跳跃次数为 `1 + dp[i + step]`。
  - 我们取所有可能的目标位置中的最小值，更新 `dp[i]`。

- **边界条件**：
  - 确保目标位置 `i + step` 不超出数组边界（`i + step < n`）。

---

##### 3. 返回结果
```cpp
return dp[0];  // 返回从起点到达终点的最小跳跃次数
```
- 最终，`dp[0]` 存储了从起点（索引 `0`）到达终点（索引 `n-1`）所需的最小跳跃次数。

---

#### 动态规划的直观理解

为了更好地理解动态规划的过程，我们可以通过一个具体的例子来模拟。

##### 示例：`nums = [2, 3, 1, 1, 4]`

1. **初始化**：
   - `dp = [INT_MAX, INT_MAX, INT_MAX, INT_MAX, 0]`
   - 因为终点（索引 `4`）无需跳跃，所以 `dp[4] = 0`。

2. **从后往前填充 `dp` 数组**：

   - **索引 3**：
     - `nums[3] = 1`，最大跳跃步数为 1。
     - 目标位置：`3 + 1 = 4`。
     - 更新：`dp[3] = min(dp[3], 1 + dp[4]) = min(INT_MAX, 1 + 0) = 1`。
     - `dp = [INT_MAX, INT_MAX, INT_MAX, 1, 0]`

   - **索引 2**：
     - `nums[2] = 1`，最大跳跃步数为 1。
     - 目标位置：`2 + 1 = 3`。
     - 更新：`dp[2] = min(dp[2], 1 + dp[3]) = min(INT_MAX, 1 + 1) = 2`。
     - `dp = [INT_MAX, INT_MAX, 2, 1, 0]`

   - **索引 1**：
     - `nums[1] = 3`，最大跳跃步数为 3。
     - 目标位置：`1 + 1 = 2`，`1 + 2 = 3`，`1 + 3 = 4`。
     - 更新：
       - `dp[1] = min(dp[1], 1 + dp[2]) = min(INT_MAX, 1 + 2) = 3`
       - `dp[1] = min(dp[1], 1 + dp[3]) = min(3, 1 + 1) = 2`
       - `dp[1] = min(dp[1], 1 + dp[4]) = min(2, 1 + 0) = 1`
     - `dp = [INT_MAX, 1, 2, 1, 0]`

   - **索引 0**：
     - `nums[0] = 2`，最大跳跃步数为 2。
     - 目标位置：`0 + 1 = 1`，`0 + 2 = 2`。
     - 更新：
       - `dp[0] = min(dp[0], 1 + dp[1]) = min(INT_MAX, 1 + 1) = 2`
       - `dp[0] = min(dp[0], 1 + dp[2]) = min(2, 1 + 2) = 2`
     - `dp = [2, 1, 2, 1, 0]`

3. **最终结果**：
   - `dp[0] = 2`，表示从起点到达终点的最小跳跃次数为 2。

---

#### 动态规划的复杂度分析

1. **时间复杂度**：
   - 外层循环遍历数组的所有位置，时间复杂度为 $O(n)$。
   - 内层循环尝试所有可能的跳跃目标，最坏情况下需要 $O(n)$ 次操作。
   - 总时间复杂度为 $O(n^2)$。

2. **空间复杂度**：
   - 使用了一个大小为 $n$ 的 `dp` 数组，空间复杂度为 $O(n)$。

---

#### 总结

1. **动态规划的核心思想**：
   - 定义状态 `dp[i]`，表示从索引 `i` 到达终点的最小跳跃次数。
   - 通过状态转移方程，从已知的状态推导出未知的状态。

2. **实现步骤**：
   - 初始化 `dp` 数组。
   - 从后往前填充 `dp` 数组，利用状态转移方程更新每个位置的最小跳跃次数。
   - 返回 `dp[0]`，即从起点到达终点的最小跳跃次数。

3. **优点与局限性**：
   - 动态规划适合解决具有最优子结构性质的问题。
   - 但其时间复杂度较高（$O(n^2)$），对于大规模数据可能不如贪心算法高效。

```cpp
class Solution {
public:
    int jump(vector<int>& nums) {
        //动态规划
        if (nums.empty()) {
            return 0; 
        }

        int size = nums.size();
        vector<long long int> dp(size,INT_MAX);
        dp[size-1]=0;

        for(int i = size-2; i >= 0; --i){
            int max_step = nums[i];
            for(int step = 1; step <= max_step && i + step < size; ++ step){
                dp[i]=min(dp[i],1+dp[i+step]);
            }
        }
        return dp[0];
    }
};
```


### 274. H-Index
```cpp
class Solution {
public:
    int hIndex(vector<int>& citations) {
        std::sort(citations.begin(),citations.end(),std::greater<int>());

        int h=0;
        for (int i = 0; i < citations.size(); ++i){
            if(citations[i] >= i + 1){
                h = i + 1; //h-index 是由 论文数量 和 引用次数 共同决定,因为排过序所以篇数有规律
            }else{
                break;
            }
        }
        return h;
    }
};
```


### 380. Insert Delete GetRandom O(1)

```cpp
class RandomizedSet {
private:
    std::vector<int> nums;
    std::unordered_map<int, int> val_to_index;
public:
    RandomizedSet() {
        
    }
    
    bool insert(int val) {
        if(val_to_index.find(val) != val_to_index.end()){
            return false;
        }
        val_to_index[val]=nums.size();
        nums.push_back(val);

        return true;
    }
    
    bool remove(int val) {
        if(val_to_index.find(val) == val_to_index.end()){
            return false;
        }
        int index = val_to_index[val];
        int last_element = nums.back();
        nums[index] = last_element;
        val_to_index[last_element] = index;
        nums.pop_back();
        val_to_index.erase(val);
        return true;
    }
    
    int getRandom() {   
        int random_index = rand() % nums.size();
        return nums[random_index];
        
    }
};

/**
 * Your RandomizedSet object will be instantiated and called as such:
 * RandomizedSet* obj = new RandomizedSet();
 * bool param_1 = obj->insert(val);
 * bool param_2 = obj->remove(val);
 * int param_3 = obj->getRandom();
 */

```





#### 类的定义

```cpp
class RandomizedSet {
private:
    std::vector<int> nums;
    std::unordered_map<int, int> val_to_index;
```

- `std::vector<int> nums;`：这是一个动态数组，用于存储集合中的所有元素。
- `std::unordered_map<int, int> val_to_index;`：这是一个哈希表（无序映射），用于存储每个元素在 `nums` 数组中的索引。键是元素值，值是该元素在 `nums` 中的索引。

#### 构造函数

```cpp
public:
    RandomizedSet() {
        
    }
```

- 这是 `RandomizedSet` 类的构造函数，初始化时不需要做任何事情，因为 `nums` 和 `val_to_index` 都会自动初始化为空。

#### 插入操作

```cpp
    bool insert(int val) {
        if(val_to_index.find(val) != val_to_index.end()){
            return false;
        }
        val_to_index[val] = nums.size();
        nums.push_back(val);
        return true;
    }
```

- `if(val_to_index.find(val) != val_to_index.end())`：首先检查 `val` 是否已经存在于 `val_to_index` 中。如果存在，说明该值已经在集合中，返回 `false` 表示插入失败。
- `val_to_index[val] = nums.size();`：如果 `val` 不存在于集合中，则将其插入到 `nums` 数组的末尾，并在 `val_to_index` 中记录它的索引。`nums.size()` 是当前数组的大小，也就是新元素将要插入的位置。
- `nums.push_back(val);`：将 `val` 添加到 `nums` 数组的末尾。
- `return true;`：返回 `true` 表示插入成功。

#### 删除操作

```cpp
    bool remove(int val) {
        if(val_to_index.find(val) == val_to_index.end()){
            return false;
        }
        int index = val_to_index[val];
        int last_element = nums.back();
        nums[index] = last_element;
        val_to_index[last_element] = index;
        nums.pop_back();
        val_to_index.erase(val);
        return true;
    }
```

- `if(val_to_index.find(val) == val_to_index.end())`：首先检查 `val` 是否存在于 `val_to_index` 中。如果不存在，返回 `false` 表示删除失败。
- `int index = val_to_index[val];`：获取 `val` 在 `nums` 数组中的索引。
- `int last_element = nums.back();`：获取 `nums` 数组的最后一个元素。
- `nums[index] = last_element;`：将 `nums` 数组的最后一个元素移动到 `val` 所在的位置，覆盖掉 `val`。
- `val_to_index[last_element] = index;`：更新 `val_to_index` 中最后一个元素的索引为 `val` 原来的索引。
- `nums.pop_back();`：从 `nums` 数组中移除最后一个元素。
- `val_to_index.erase(val);`：从 `val_to_index` 中删除 `val` 的记录。
- `return true;`：返回 `true` 表示删除成功。

#### 获取随机元素

```cpp
    int getRandom() {   
        int random_index = rand() % nums.size();
        return nums[random_index];
    }
```

- `int random_index = rand() % nums.size();`：生成一个从 `0` 到 `nums.size() - 1` 的随机索引。
- `return nums[random_index];`：返回 `nums` 数组中对应随机索引位置的元素。

#### 总结

```cpp
/**
 * Your RandomizedSet object will be instantiated and called as such:
 * RandomizedSet* obj = new RandomizedSet();
 * bool param_1 = obj->insert(val);
 * bool param_2 = obj->remove(val);
 * int param_3 = obj->getRandom();
 */
```

- 这段注释说明了如何使用 `RandomizedSet` 类。你可以创建一个 `RandomizedSet` 对象，并调用其 `insert`、`remove` 和 `getRandom` 方法来执行相应的操作。

#### 关键点总结：
1. **插入**：通过 `unordered_map` 快速判断元素是否存在，若不存在则插入到 `vector` 的末尾，并更新 `unordered_map`。
2. **删除**：通过 `unordered_map` 快速定位要删除的元素，然后将数组末尾的元素移到要删除元素的位置，最后删除末尾元素并更新 `unordered_map`。
3. **获取随机元素**：通过 `rand()` 函数生成随机索引，直接访问 `vector` 中的元素。

这个设计确保了插入、删除和获取随机元素的时间复杂度都是 O(1)。



---

#### **1. 数据的来源：反复调用操作**
在这道题中，数据的来源并不是预先定义好的，而是通过 **反复调用类的方法**（`insert`、`remove` 和 `getRandom`）动态生成和管理的。换句话说：
- 你创建了一个 `RandomizedSet` 对象。
- 然后通过调用 `insert` 方法插入数据。
- 再通过 `remove` 方法删除数据。
- 最后通过 `getRandom` 方法随机获取数据。

这些方法的操作会动态地修改类的成员变量（`nums` 和 `val_to_index`），从而形成一个动态的数据集合。

---

#### **2. 示例运行流程**
假设我们按照以下步骤调用方法：

```cpp
RandomizedSet* obj = new RandomizedSet(); // 创建对象

bool param_1 = obj->insert(1); // 插入 1，返回 true
bool param_2 = obj->insert(2); // 插入 2，返回 true
bool param_3 = obj->insert(1); // 再次插入 1，返回 false（因为 1 已存在）

int param_4 = obj->getRandom(); // 随机返回 1 或 2

bool param_5 = obj->remove(1); // 删除 1，返回 true
bool param_6 = obj->remove(3); // 删除 3，返回 false（因为 3 不存在）

int param_7 = obj->getRandom(); // 随机返回 2（此时集合中只有 2）
```

在这个过程中：
- 数据是通过 `insert` 方法逐步添加到集合中的。
- 数据的状态（即 `nums` 和 `val_to_index` 的内容）随着每次调用方法而动态变化。

---

#### **3. 类的设计与数据的动态管理**
这道题的核心思想是设计一个类，使得它能够动态地管理数据，并支持高效的插入、删除和随机获取操作。具体来说：
- **插入**：将新值添加到集合中。
- **删除**：从集合中移除某个值。
- **随机获取**：从集合中随机选择一个值。

所有这些操作都依赖于类的成员变量（`nums` 和 `val_to_index`），它们在每次调用方法时被更新。

---

#### **4. 成员变量的作用**
为了更好地理解数据的动态管理，我们可以回顾一下两个成员变量的作用：
1. **`nums`（动态数组）**：
   - 存储集合中的所有元素。
   - 支持随机访问（用于 `getRandom` 操作）。
   - 支持尾部插入和删除（用于 `insert` 和 `remove` 操作）。

2. **`val_to_index`（哈希表）**：
   - 记录每个值在 `nums` 中的索引。
   - 支持快速查找（用于检查某个值是否存在）。
   - 支持快速更新（用于删除操作时交换元素）。

这两个成员变量共同协作，确保了插入、删除和随机获取操作的时间复杂度均为 O(1)。

---

#### **5. 数据的生命周期**
数据的生命周期可以分为以下几个阶段：
1. **初始化**：
   - 当你创建 `RandomizedSet` 对象时，`nums` 和 `val_to_index` 被初始化为空。

2. **动态更新**：
   - 每次调用 `insert` 方法时，`nums` 和 `val_to_index` 会被更新。
   - 每次调用 `remove` 方法时，`nums` 和 `val_to_index` 也会被更新。

3. **销毁**：
   - 当 `RandomizedSet` 对象被销毁时，`nums` 和 `val_to_index` 也会被自动清理。

---

#### **6. 总结**
- 数据的来源是通过 **反复调用类的方法** 动态生成的。
- 类的成员变量（`nums` 和 `val_to_index`）负责存储和管理数据。
- 每次调用方法时，数据的状态会发生变化，从而形成一个动态的数据集合。

### 238. Product of Array Except Self
```cpp
//暴力
class Solution {
public:
    vector<int> productExceptSelf(vector<int>& nums) {
        vector<int> products(nums.size(),1);
        for(int i = 0; i <= nums.size() - 1; ++i){
            int product = 1;
            for(int j = 0; j <= nums.size() - 1; ++j){
                if(j != i){
                    product *= nums[j];
                }
                products[i] = product;
            }
        }
        return products;
    }
};
```


```cpp
class Solution {
public:
    vector<int> productExceptSelf(vector<int>& nums) {
        int n = nums.size();
        vector<int> result(n, 1); // 全初始化为 1
        int prefix = 1;
        //result[i] = (nums[0] * nums[1] * ... * nums[i-1]) * 
        //(nums[i+1] * nums[i+2] * ... * nums[n-1])
        for (int i = 0; i < n; ++i) {
            result[i] = prefix;
            prefix *= nums[i];
        }
        int suffix = 1;
        for (int i = n - 1; i >= 0; --i) {
            result[i] *= suffix;
            suffix *= nums[i];
        }
        return result;
    }
};


```


### 134. Gas Station
```cpp
//暴力
class Solution {
public:
    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {
        int n = gas.size();
        vector<int> tank_gas(gas.size(),0);
        vector<int> start_site(gas.size(),-1);


        for (int start = 0; start < n; ++start){
            tank_gas[start] = 0;
            for (int i = 0; i < n; ++i){
                int current_station = (start + i) % n;
                tank_gas[start] += gas[current_station] - cost[current_station];

                if(tank_gas[start]  < 0){
                    break;
                }
            }
            if(tank_gas[start] >= 0){
                start_site[start] = start;
            }
        }
        for(int i = 0; i <= gas.size() - 1; ++i){
            if(start_site[i] != -1){
                return start_site[i];
            }
        }
        return -1;
    }
};

```
```cpp
class Solution {
public:
    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {
        int total_left = 0;
        int curr_tank = 0;
        int starting_station = 0;
        
        for (int i = 0; i < gas.size(); ++i){
            total_left += gas[i] - cost[i];
            curr_tank += gas[i] - cost[i];

            if(curr_tank < 0){
                starting_station = i + 1;
                curr_tank = 0;
            }
        }
        return total_left >= 0 ? starting_station : -1;
    }
};

```


### 135. Candy
```cpp
class Solution {
public:
    int candy(vector<int>& ratings) {
        int length = ratings.size();
        vector<int> candies(length,1);

        for(int i = 1; i < length; ++i){
            if(ratings[i] > ratings[i-1]){
                candies[i] = candies[i - 1] + 1;
            }
        }

        for(int i = length - 2; i > -1; --i){
            if(ratings[i] > ratings[i+1]){
                candies[i] = max((candies[i + 1] + 1),candies[i]);
            }
        }

        return accumulate(candies.begin(),candies.end(),0);
    }
};
```



### 42. Trapping Rain Water

```cpp
//动态规划
class Solution {
public:
    int trap(vector<int>& height) {
        if(height.size() <= 2){return 0;}

        vector<int> left_max(height.size(),0);
        vector<int> right_max(height.size(),0);
        vector<int> water_height(height.size(),0);
        int total_water = 0;

        left_max[0] = height[0];
        for(int i = 1; i < height.size(); ++i){
            left_max[i] = max(left_max[i-1], height[i]);
        }

        right_max[height.size()-1] = height[height.size()-1];
        for(int i = height.size() - 2; i >= 0; --i){
            right_max[i] = max(right_max[i+1], height[i]);
        }

        for(int i = 1; i <= height.size()-2; ++ i){
            if (min(left_max[i],right_max[i]) - height[i] > 0){
                water_height[i] = min(left_max[i],right_max[i]) - height[i];
                total_water += water_height[i];
            }else{
                water_height[i] = 0;
            }
        }
        return total_water;
    }
};
```

```cpp
class Solution {
public:
    int trap(vector<int>& height) {
        int total_water = 0;
        int left = 0;
        int right = height.size() - 1;
        int left_max = 0;
        int right_max = 0;

        while(left < right){
            if (height[left] < height[right]){
                if(height[left]>=left_max){
                    left_max = height[left];
                }else{
                    total_water += left_max - height[left];
                }
                left++;
            }else{
                if(height[right] >= right_max){
                    right_max = height[right];
                }else{
                    total_water += right_max - height[right];
                }
                right--;
            }
        }

        return total_water;
    }
};
```



### 13. Roman to Integer
```cpp
class Solution {
public:
    int romanToInt(string s) {
        unordered_map<char, int> roman_to_int = {
            {'I',1},
            {'V',5},
            {'X',10},
            {'L',50},
            {'C',100},
            {'D',500},
            {'M',1000}
        };

        int total = 0;
        int prev_value = 0;

        for (char c:s){
            int current_value = roman_to_int[c];

            if(current_value>prev_value){
                total += current_value - 2 * prev_value;
            }else{
                total += current_value;
            }
            prev_value = current_value;
        }
        return total;
    }
};

```
### 12. Integer to Roman
```cpp
class Solution {
public:
    string intToRoman(int num) {
        vector<pair<int, string>> value_symbols = {
        {1000, "M"}, {900, "CM"}, {500, "D"}, {400, "CD"},
        {100, "C"}, {90, "XC"}, {50, "L"}, {40, "XL"},
        {10, "X"}, {9, "IX"}, {5, "V"}, {4, "IV"}, {1, "I"}
        };

        string result = "";

        for (const auto& [value, symbol] : value_symbols){
            while (num >= value){
                result += symbol;
                num -= value;
            }
        }
        return result;
    }
};

```


### 58. Length of Last Word
```cpp
class Solution {
public:
    int lengthOfLastWord(string s) {
        int n = s.size();
        int length = 0;

        int i = n - 1;
        while(i>=0&&s[i]==' '){
            i--;
        }
        while(i>=0&&s[i]!=' '){
            length++;
            i--;
        }
        return length;
    }
};
```


### 14. Longest Common Prefix
```cpp
class Solution {
public:
    string longestCommonPrefix(vector<string>& strs) {
        if(strs.empty()) return "";
        string prefix=strs[0];
        for(int i=1;i<strs.size();++i){
            while(strs[i].find(prefix)!=0){
            // 如果 prefix 是 strs[i] 的前缀，那么 strs[i].find(prefix) 应该返回 0，因为前缀必须从字符串的第一个字符开始匹配。
            // 如果 prefix 不是 strs[i] 的前缀，find 返回的值将不是 0，可能是因为：
            // prefix 在 strs[i] 中不存在（返回 std::string::npos）。
            // prefix 存在于 strs[i] 中，但不在开头（返回非零的索引）。
                prefix.pop_back();
                if(prefix.empty()) return "";
            }
        }
        return prefix;
    }
};
```

### 151. Reverse Words in a String
```cpp
class Solution {
public:
    string reverseWords(string s) {
        vector<string> words;
        string word;
        stringstream ss(s);
        while(ss>>word){
            words.push_back(word);
        }
        std::reverse(words.begin(),words.end());

        string result;
        for(int i=0;i<words.size();++i){
            result += words[i];
            if(i != words.size() - 1){
                result += " ";
            }
        }
        return result;
    }
};

```



### 6. Zigzag Conversion

```cpp
class Solution {
public:
    string convert(string s, int numRows) {
        if (numRows == 1 || s.size() <= numRows) return s;
        
        string result;
        result.reserve(s.size());  // 预先分配内存
        
        int cycleLen = 2 * numRows - 2;  // 每个周期的长度
        
        for (int i = 0; i < numRows; ++i) {
            for (int j = 0; i + j < s.size(); j += cycleLen) {
                result += s[i + j];  // 垂直方向的字符
                
                // 对于非首尾行，还需要添加斜向上的字符
                if (i != 0 && i != numRows - 1 && j + cycleLen - i < s.size()) {
                    result += s[j + cycleLen - i];
                }
            }
        }
        
        return result;
    }
};

```


### 28. Find the Index of the First Occurrence in a String
```cpp

class Solution {
public:
    int strStr(string haystack, string needle) {
        size_t pos = haystack.find(needle);
        return (pos != std::string::npos)?static_cast<int>(pos):-1;
    }
};

```
### 68. Text Justification
```cpp
using namespace std;

class Solution {
public:
    vector<string> fullJustify(vector<string>& words, int maxWidth) {
        vector<string> result;
        vector<string> line;
        int lineLength = 0;

        for (const string& word : words) {
            if (lineLength + word.size() + line.size() > maxWidth) {
                int totalSpaces = maxWidth - lineLength;
                int gaps = line.size() - 1;
                string formattedLine = line[0];
                
                if (gaps == 0) {
                    formattedLine += string(totalSpaces, ' ');
                } else {
                    int spacesPerGap = totalSpaces / gaps;
                    int extraSpaces = totalSpaces % gaps;
                    
                    for (int i = 1; i < line.size(); ++i) {
                        formattedLine += string(spacesPerGap + (i <= extraSpaces ? 1 : 0), ' ') + line[i];
                    }
                }
                result.push_back(formattedLine);
                line.clear();
                lineLength = 0;
            }
            line.push_back(word);
            lineLength += word.size();
        }

        string lastLine = "";
        for (int i = 0; i < line.size(); ++i) {
            lastLine += line[i] + (i < line.size() - 1 ? " " : "");
        }
        lastLine += string(maxWidth - lastLine.size(), ' ');
        result.push_back(lastLine);

        return result;
    }
};
```


### 125. Valid Palindrome

```cpp
class Solution {
public:
    bool isPalindrome(string s) {
        string cleaned = "";

        // // 自己实现is alphabetic or numeric函数
        // bool myIsalnum(char c) {
        //     return (c >= 'a' && c <= 'z') ||
        //            (c >= 'A' && c <= 'Z') ||
        //            (c >= '0' && c <= '9');
        // }
        
        // // 自己实现tolower函数
        // char myTolower(char c) {
        //     if (c >= 'A' && c <= 'Z') {
        //         return c - 'A' + 'a';
        //     }
        //     return c;
        // }

        for (char c : s){
            if (isalnum(c)){
                cleaned += tolower(c);
            }
        }
        int left = 0;
        int right = cleaned.length() - 1;

        while(left < right){
            if(cleaned[left]!=cleaned[right]){
                return false;
            }
            left++;
            right--;
        }
        return true;

    }
};

```



### 392. Is Subsequence

```cpp
//被隔开也是子串
class Solution {
public:
    bool isSubsequence(string s, string t) {
        if(s.empty())   return true;

        if(t.empty())   return false;

        int sIndex = 0;
        int sLen = s.length();

        for (char c : t){
            if (s[sIndex]==c){
                sIndex++;
                if (sIndex == sLen){
                    return true;
                }
            }
        }
        return false;
    }
};
```



### 167. Two Sum II - Input Array Is Sorted
```cpp
class Solution {
public:
    vector<int> twoSum(vector<int>& numbers, int target) {
        int left = 0;
        int right = numbers.size() - 1;
        while (left < right){
            int current_sum = numbers[left] + numbers[right];
            if (current_sum == target){
                return {left + 1, right + 1}; //索引从 1 开始
            }else if(current_sum < target){
                left ++;
            }else{
                right --;
            }
        }

        return {};
    }
};

```


### 11. Container With Most Water

```cpp

class Solution {
public:
    int maxArea(vector<int>& height) {
        int left = 0;
        int right = height.size() - 1;
        int maxArea = 0;

        while (left < right){
            int width = right - left;
            int minHeight = min(height[left], height[right]);

            int currentArea = width * minHeight;
            maxArea = max(maxArea, currentArea);
            if (height[left]<height[right]){
                left ++;
            }else{
                right --;
            }
        }
        return maxArea;
    }
};

```


### 15. 3Sum

```cpp
class Solution {
public:
    vector<vector<int>> threeSum(vector<int>& nums) {
        vector<vector<int>> result;
        if(nums.size()<3) return result;
        sort(nums.begin(),nums.end());
        for(int i=0;i<nums.size()-2;++i){
            if(i>0&&nums[i]==nums[i-1])continue;//跳过重复元素
            int left=i+1,right=nums.size()-1;
            while(left<right){
                int sum=nums[i]+nums[left]+nums[right];
                if(sum==0){
                    result.push_back({nums[i],nums[left],nums[right]});
                while(left<right&&nums[left]==nums[left+1])++left;//跳重
                while(left<right&&nums[right]==nums[right-1])--right;//跳重
                ++left;
                --right;
                }else if(sum<0){
                    ++left;
                }else{
                    --right;
                }
            }
        }
        return result;
    }
};

```

### 209. Minimum Size Subarray Sum
```cpp
class Solution {
public:
    int minSubArrayLen(int target, vector<int>& nums) {
        int n = nums.size();
        int left = 0;
        int current_sum = 0;
        int min_length = INT32_MAX;

        for (int right = 0; right < n; ++right){
            current_sum += nums[right];
            while(current_sum >= target){
                min_length = min(min_length, right - left + 1);
                current_sum -= nums[left];
                ++left;
            }
        }
        return min_length == INT32_MAX ? 0: min_length;
    }
};
```


### 3. Longest Substring Without Repeating Characters
<img width="505" alt="{A12D595C-751B-4A8F-9290-DA9458537C13}" src="https://github.com/user-attachments/assets/32a82ba6-2f92-4257-9d3a-e4337a28c9ab" />

```cpp

class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        vector<int> last_pos(256, -1); // 记录字符最后出现的位置
        int max_len = 0;
        int left = 0; // 滑动窗口的左边界
        for (int i = 0; i < s.size(); ++i) {
            char c = s[i];
            // 如果当前字符之前出现过且在窗口内，更新左边界
            if (last_pos[c] >= left) {
                left = last_pos[c] + 1;
            }
            last_pos[c] = i; // 更新当前字符的位置
            max_len = max(max_len, i - left + 1); // 计算当前窗口长度
        }
        return max_len;
    }
};
```

### 30. Substring with Concatenation of All Words
```cpp

using namespace std;

class Solution {
public:
    vector<int> findSubstring(string s, vector<string>& words) {
        vector<int> result; // 存储结果的起始索引
        if (s.empty() || words.empty()) return result;

        int word_len = words[0].size();       // 每个单词的长度
        int word_count = words.size();        // 单词总数
        int total_len = word_len * word_count; // 所有单词拼接后的总长度

        // 如果字符串长度小于总长度，直接返回空结果
        if (s.size() < total_len) return result;

        // 构建目标单词频率表
        unordered_map<string, int> target_map;
        for (const string& word : words) {
            target_map[word]++;
        }

        // 遍历字符串的每个可能起点（偏移量从 0 到 word_len - 1）
        for (int i = 0; i < word_len; ++i) {
            unordered_map<string, int> current_map; // 当前窗口的单词频率表
            int left = i, right = i, count = 0;     // 滑动窗口的左右边界和有效单词计数

            while (right + word_len <= s.size()) {
                // 提取当前单词
                string word = s.substr(right, word_len);
                right += word_len;

                if (target_map.find(word) != target_map.end()) {
                    // 如果当前单词在目标中，更新当前窗口的频率表
                    current_map[word]++;
                    count++;

                    // 如果某个单词出现次数过多，调整左边界
                    while (current_map[word] > target_map[word]) {
                        string left_word = s.substr(left, word_len);
                        current_map[left_word]--;
                        count--;
                        left += word_len;
                    }
                } else {
                    // 如果遇到不在目标中的单词，重置窗口
                    current_map.clear();
                    count = 0;
                    left = right;
                }

                // 如果窗口中的单词数量等于目标单词数量，记录起始索引
                if (count == word_count) {
                    result.push_back(left);

                    // 移动左边界，继续寻找下一个可能的子串
                    string left_word = s.substr(left, word_len);
                    current_map[left_word]--;
                    count--;
                    left += word_len;
                }
            }
        }

        return result;
    }
};

```
### 76. Minimum Window Substring

```cpp
//算法的关键在于 “记录所有有效窗口，并只保留最短的那个” 。通过动态调整窗口（扩展右边界和收缩左边界），找到所有可能的有效窗口，同时始终保留当前找到的最短窗口。
using namespace std;

class Solution {
public:
    string minWindow(string s, string t) {
        // 如果 t 的长度大于 s 的长度，直接返回空字符串
        if (t.size() > s.size()) return "";

        // 哈希表 target_map：记录 t 中每个字符的目标数量
        unordered_map<char, int> target_map;
        for (char c : t) {
            target_map[c]++; // 统计 t 中每个字符的出现次数
        }

        // 哈希表 current_map：记录当前窗口中每个字符的实际数量
        unordered_map<char, int> current_map;

        // required 是需要满足的字符种类数（t 中不同字符的数量）
        int required = target_map.size();

        // formed 是当前窗口中已经满足的字符种类数
        int formed = 0;

        // 滑动窗口的左右边界
        int left = 0, right = 0;

        // 最小窗口的长度和起始位置
        int min_len = INT_MAX; // 初始化为最大值
        int start_index = 0;   // 记录最小窗口的起始位置

        // 开始滑动窗口
        while (right < s.size()) { // 右边界不能超出 s 的范围
            char right_char = s[right]; // 当前右边界的字符
            current_map[right_char]++; // 把右边界的字符加入窗口

            // 如果当前字符在 t 中，并且它的数量达到了目标数量
            if (target_map.find(right_char) != target_map.end() &&
                current_map[right_char] == target_map[right_char]) {
                formed++; // 已经满足的字符种类数加一
            }

            // 当窗口中的字符满足了 t 的要求时，尝试缩小窗口
            while (left <= right && formed == required) {
                char left_char = s[left]; // 当前左边界的字符

                // 更新最小窗口
                if (right - left + 1 < min_len) { // 如果当前窗口更短
                    min_len = right - left + 1;  // 更新最小长度
                    start_index = left;          // 更新起始位置
                }

                // 移动左边界，缩小窗口
                current_map[left_char]--; // 减少左边界的字符数量

                // 如果某个字符的数量低于目标数量
                if (target_map.find(left_char) != target_map.end() &&
                    current_map[left_char] < target_map[left_char]) {
                    formed--; // 已经满足的字符种类数减一
                }

                left++; // 左边界向右移动
            }

            right++; // 右边界向右移动，继续扩展窗口
        }

        // 如果没有找到符合条件的窗口，返回空字符串
        if (min_len == INT_MAX) {
            return "";
        } else {
            // 返回最小窗口的子串
            return s.substr(start_index, min_len);
        }
    }
};

```



### 36. Valid Sudoku

```cpp
class Solution {
public:
    bool isValidSudoku(vector<vector<char>>& board) {
        std::unordered_set<char> rows[9];
        std::unordered_set<char> cols[9];
        std::unordered_set<char> boxs[9];
        for(int i=0;i<9;++i){
            for(int j=0;j<9;++j){
                char num = board[i][j];
                if(num=='.')continue;
                int box_index=(i/3)*3+(j/3);
                if(rows[i].count(num)) return false;
                if(cols[j].count(num)) return false;
                if(boxs[box_index].count(num)) return false;
                rows[i].insert(num);
                cols[j].insert(num);
                boxs[box_index].insert(num);
            }
        }
        return true;
    }
};

```
```cpp
//位运算版

class Solution {
public:
    bool isValidSudoku(std::vector<std::vector<char>>& board) {
        // 使用整数数组来表示行、列和子九宫格的状态
        int rows[9] = {0};
        int cols[9] = {0};
        int boxes[9] = {0};

        // 遍历整个棋盘
        for (int i = 0; i < 9; ++i) {
            for (int j = 0; j < 9; ++j) {
                char ch = board[i][j];
                if (ch == '.') continue; // 跳过空格

                // 将字符转换为数字（'1' -> 1, '2' -> 2, ..., '9' -> 9）
                int num = ch - '0';

                // 计算当前数字对应的二进制位
                int bit = 1 << (num - 1);

                // 计算当前数字所属的子九宫格索引
                int box_index = (i / 3) * 3 + (j / 3);

                // 检查行、列和子九宫格中是否已有该数字
                if ((rows[i] & bit) != 0) return false;
                if ((cols[j] & bit) != 0) return false;
                if ((boxes[box_index] & bit) != 0) return false;

                // 将数字标记为已存在
                rows[i] |= bit;
                cols[j] |= bit;
                boxes[box_index] |= bit;
            }
        }

        // 如果没有发现冲突，则棋盘有效
        return true;
    }
};
```

### 54. Spiral Matrix
```cpp
class Solution {
public:
    vector<int> spiralOrder(vector<vector<int>>& matrix) {
        if (matrix.empty() || matrix[0].empty()) return {};
        vector<int> result;
        int top = 0, bottom = matrix.size() - 1;
        int left = 0, right = matrix[0].size() - 1;
        while (top <= bottom && left <= right) {
            for (int col = left; col <= right; ++col) result.push_back(matrix[top][col]);
            ++top;
            for (int row = top; row <= bottom; ++row) result.push_back(matrix[row][right]);
            --right;
            if (top <= bottom) {
                for (int col = right; col >= left; --col) result.push_back(matrix[bottom][col]);
                --bottom;
            }
            if (left <= right) {
                for (int row = bottom; row >= top; --row) result.push_back(matrix[row][left]);
                ++left;
            }
        }
        return result;
    }
};
```


### 48. Rotate Image
<img width="205" alt="{C54786CC-0E49-4A2F-BA91-D5C0C2972B56}" src="https://github.com/user-attachments/assets/aa897201-f5f1-4568-931d-0d6d6052c9b2" />

```cpp
using namespace std;

class Solution {
public:
    void rotate(vector<vector<int>>& matrix) {
        //rotateDirectly(matrix);
        
        rotateByFlipping(matrix);
    }

private:
    void rotateDirectly(vector<vector<int>>& matrix) {
        int n = matrix.size();
        for (int i = 0; i < n / 2; ++i){
            for (int j = i; j < n - 1 - i; ++ j){
                int temp = matrix[i][j];
                matrix[i][j]=matrix[n-1-j][i];
                matrix[n-1-j][i]=matrix[n-1-i][n-1-j];
                matrix[n-1-i][n-1-j]=matrix[j][n-1-i];
                matrix[j][n-1-i]=temp;
            }

        }
    }
    void rotateByFlipping(vector<vector<int>>& matrix) {
        int n=matrix.size();
        for(int i=0;i<n/2;++i){
            swap(matrix[i],matrix[n-1-i]);
        }
        for(int i=0;i<n;++i){
            for(int j=i+1;j<n;++j){
                swap(matrix[i][j],matrix[j][i]);
        }
        }
    }
};

```



### 73. Set Matrix Zeroes
```cpp
class Solution {
public:
    void setZeroes(vector<vector<int>>& matrix) {
        int m = matrix.size();//rows how many
        int n = matrix[0].size();//cols how many
        bool firstRowHasZero = false, firstColHasZero = false;
        for (int j = 0; j < n; ++j) {
            if（matrix[0][j]==0){
                firstRowHasZero = true;
                break;
            }
        }
        for (int i = 0; i < m; ++i){
            if (matrix[i][0] == 0){
                firstColHasZero = true;
                break;
            }
        }
        for(int i = 1; i < m; ++i){
            for(int j = 1;j < n; ++j){
                if (matrix[i][j]==0){
                    matrix[i][0]=0;
                    matrix[0][j]=0;
                }
            }
        }
        for(int i = 1; i < m; ++i){
            for(int j = 1;j < n; ++j){
                if (matrix[i][0]==0||matrix[0][j]==0){
                    matrix[i][j]=0;
                }
            }
        }
        if (firstRowHasZero){
            for(int j=0;j<n;++j){
                matrix[0][j]=0;
            }
        }
        if (firstColHasZero){
            for(int i=0;i<m;++i){
                matrix[i][0]=0;
            }
        }
    }
};
```

### 289. Game of Life
```cpp
using namespace std;

class Solution {
public:
    void gameOfLife(vector<vector<int>>& board) {
        // 调用不同的算法（可以根据需要选择）
        // convolution(board);   // 卷积方法
        //bruteForce(board);    // 暴力遍历方法
        eightDirectionShift(board); // 八向平移方法
    }

private:
    // 方法 1: 卷积操作（模拟卷积核）
    void convolution(vector<vector<int>>& board) {
        int m = board.size(), n = board[0].size();
        vector<vector<int>> neighbors(m, vector<int>(n, 0));

        // 定义卷积核的方向偏移
        vector<pair<int, int>> directions = {
            {-1, -1}, {-1, 0}, {-1, 1},
            {0, -1},          {0, 1},
            {1, -1}, {1, 0}, {1, 1}
        };

        // 统计每个细胞的邻居数量
        for (int i = 0; i < m; ++i) {
            for (int j = 0; j < n; ++j) {
                if (board[i][j] == 1) { // 只统计活细胞的影响
                    for (auto& dir : directions) {
                        int ni = i + dir.first, nj = j + dir.second;
                        if (ni >= 0 && ni < m && nj >= 0 && nj < n) {
                            neighbors[ni][nj]++;
                        }
                    }
                }
            }
        }

        // 根据邻居数量更新状态
        for (int i = 0; i < m; ++i) {
            for (int j = 0; j < n; ++j) {
                int liveNeighbors = neighbors[i][j];
                if (board[i][j] == 1) { // 当前是活细胞
                    if (liveNeighbors < 2 || liveNeighbors > 3) {
                        board[i][j] = 0; // 死亡
                    }
                } else { // 当前是死细胞
                    if (liveNeighbors == 3) {
                        board[i][j] = 1; // 复活
                    }
                }
            }
        }
    }

    // 方法 2: 暴力遍历
    void bruteForce(vector<vector<int>>& board) {
        int m = board.size(), n = board[0].size();
        vector<vector<int>> nextState = board; // 创建一个副本存储下一状态

        // 定义方向偏移
        vector<pair<int, int>> directions = {
            {-1, -1}, {-1, 0}, {-1, 1},
            {0, -1},          {0, 1},
            {1, -1}, {1, 0}, {1, 1}
        };

        // 遍历每个细胞
        for (int i = 0; i < m; ++i) {
            for (int j = 0; j < n; ++j) {
                int liveNeighbors = 0;

                // 统计邻居数量
                for (auto& dir : directions) {
                    int ni = i + dir.first, nj = j + dir.second;
                    if (ni >= 0 && ni < m && nj >= 0 && nj < n && board[ni][nj] == 1) {
                        liveNeighbors++;
                    }
                }

                // 更新下一状态
                if (board[i][j] == 1) { // 当前是活细胞
                    if (liveNeighbors < 2 || liveNeighbors > 3) {
                        nextState[i][j] = 0; // 死亡
                    }
                } else { // 当前是死细胞
                    if (liveNeighbors == 3) {
                        nextState[i][j] = 1; // 复活
                    }
                }
            }
        }

        // 更新原矩阵
        board = nextState;
    }

    // 方法 3: 八向平移（创建 9 个矩阵）
    void eightDirectionShift(vector<vector<int>>& board) {
        int m = board.size(), n = board[0].size();
        vector<vector<int>> neighbors(m, vector<int>(n, 0)); // 存储邻居数量

        // 定义方向偏移
        vector<pair<int, int>> directions = {
            {-1, -1}, {-1, 0}, {-1, 1},
            {0, -1},          {0, 1},
            {1, -1}, {1, 0}, {1, 1}
        };

        // 平移并累加邻居数量
        for (auto& dir : directions) {
            vector<vector<int>> shifted(m, vector<int>(n, 0));
            for (int i = 0; i < m; ++i) {
                for (int j = 0; j < n; ++j) {
                    int ni = i + dir.first, nj = j + dir.second;
                    if (ni >= 0 && ni < m && nj >= 0 && nj < n) {
                        shifted[i][j] = board[ni][nj];
                    }
                }
            }
            // 累加到邻居矩阵
            for (int i = 0; i < m; ++i) {
                for (int j = 0; j < n; ++j) {
                    neighbors[i][j] += shifted[i][j];
                }
            }
        }

        // 根据邻居数量更新状态
        for (int i = 0; i < m; ++i) {
            for (int j = 0; j < n; ++j) {
                int liveNeighbors = neighbors[i][j];
                if (board[i][j] == 1) { // 当前是活细胞
                    if (liveNeighbors < 2 || liveNeighbors > 3) {
                        board[i][j] = 0; // 死亡
                    }
                } else { // 当前是死细胞
                    if (liveNeighbors == 3) {
                        board[i][j] = 1; // 复活
                    }
                }
            }
        }
    }
};

```




### 383. Ransom Note
```cpp
class Solution {
public:
    bool canConstruct(string ransomNote, string magazine) {
        // 创建两个大小为26的数组，用于记录字符频率
        int ransom_count[26] = {0};
        int magazine_count[26] = {0};
        
        // 统计ransomNote中每个字符的出现次数
        for (char c : ransomNote) {
            ransom_count[c - 'a']++;
        }
        
        // 统计magazine中每个字符的出现次数
        for (char c : magazine) {
            magazine_count[c - 'a']++;
        }
        
        // 比较两个数组，检查是否满足需求
        for (int i = 0; i < 26; ++i) {
            if (ransom_count[i] > magazine_count[i]) {
                return false; // 如果ransomNote的需求超过magazine的供给
            }
        }
        
        return true;
    }
};

```

### 205. Isomorphic Strings
```cpp
//不是凯撒密码
using namespace std;

class Solution {
public:
    bool isIsomorphic(string s, string t) {
        // 如果长度不同，直接返回 false
        if (s.size() != t.size()) {
            return false;
        }

        // 创建两个哈希表，分别记录 s -> t 和 t -> s 的映射
        unordered_map<char, char> s_to_t;
        unordered_map<char, char> t_to_s;

        // 遍历字符串
        for (int i = 0; i < s.size(); ++i) {
            char char_s = s[i];
            char char_t = t[i];

            // 检查 s -> t 的映射
            if (s_to_t.find(char_s) != s_to_t.end()) {
                if (s_to_t[char_s] != char_t) { // 如果映射不一致，返回 false
                    return false;
                }
            } else {
                s_to_t[char_s] = char_t; // 建立新的映射
            }

            // 检查 t -> s 的映射
            if (t_to_s.find(char_t) != t_to_s.end()) {
                if (t_to_s[char_t] != char_s) { // 如果映射不一致，返回 false
                    return false;
                }
            } else {
                t_to_s[char_t] = char_s; // 建立新的映射
            }
        }

        // 如果所有字符都满足映射关系，返回 true
        return true;
    }
};
```
### 290. Word Pattern
```cpp

using namespace std;


class Solution {
public:
    bool wordPattern(string pattern, string s) {
        // 使用 istringstream 分割字符串 s
        istringstream iss(s);
        vector<string> words;
        string word;
        while (iss >> word) {
            words.push_back(word);
        }
        
        // 如果模式长度和单词数量不一致，直接返回 false
        if (pattern.size() != words.size()) {
            return false;
        }
        
        // 创建两个哈希表，分别记录字符和单词首次出现的位置
        unordered_map<char, int> char_index;  // 字符 -> 首次出现的索引
        unordered_map<string, int> word_index; // 单词 -> 首次出现的索引
        
        // 遍历模式和单词列表
        for (int i = 0; i < pattern.size(); ++i) {
            char c = pattern[i];
            string w = words[i];
            
            // 检查字符和单词的首次出现位置是否一致
            if (char_index[c] != word_index[w]) {
                return false;
            }
            
            // 记录字符和单词的首次出现位置（从 1 开始，避免与默认值 0 冲突）
            char_index[c] = word_index[w] = i + 1;
        }
        
        // 如果所有映射都一致，返回 true
        return true;
    }
};
```


### 242. Valid Anagram
```py

class Solution:
    def isAnagram(self, s: str, t: str) -> bool:
        if len(s) != len(t):
            return False
        return sorted(s) == sorted(t)
        
```

```py
class Solution:
    def isAnagram(self, s: str, t: str) -> bool:
        # 如果长度不同，直接返回 False
        if len(s) != len(t):
            return False
        
        # 初始化频率数组和位掩码
        count = [0] * 26
        bitmask = 0
        
        for i in range(len(s)):
            # 更新频率数组
            s_char = ord(s[i]) - ord('a')
            t_char = ord(t[i]) - ord('a')
            count[s_char] += 1
            count[t_char] -= 1
            
            # 更新位掩码
            bitmask ^= (1 << s_char)
            bitmask ^= (1 << t_char)
        
        # 检查位掩码是否为 0 且频率数组是否全为 0
        return bitmask == 0 and all(c == 0 for c in count)

```
```py

class Solution:
    def isAnagram(self, s: str, t: str) -> bool:
        if len(s) != len(t):
            return False
        count_s = Counter(s)
        count_t = Counter(t)
        return count_s == count_t
```
### 49. Group Anagrams
```py

class Solution:
    def groupAnagramsBySort(self, strs: List[str]) -> List[List[str]]:
        """使用排序法分组字母异位词"""
        groups = defaultdict(list)
        for s in strs:
            key = tuple(sorted(s))
            groups[key].append(s)
        return list(groups.values())
    
    def groupAnagramsByCount(self, strs: List[str]) -> List[List[str]]:
        """使用计数法分组字母异位词"""
        groups = defaultdict(list)
        for s in strs:
            count = [0] * 26
            for c in s:
                count[ord(c) - ord('a')] += 1
            groups[tuple(count)].append(s)
        return list(groups.values())
```

### 1. Two Sum
```cpp
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        unordered_map<int, int> num_map;  // 创建哈希表：数值 -> 索引
        
        for (int i = 0; i < nums.size(); ++i) {
            int complement = target - nums[i];  // 计算当前元素需要的补数
            
            // 检查补数是否已存在于哈希表中
            if (num_map.find(complement) != num_map.end()) {
                return {num_map[complement], i};  // 找到解，返回两个索引
            }
            
            num_map[nums[i]] = i;  // 将当前元素存入哈希表
        }
        
        return {};  // 理论上不会执行（题目保证有解）
    }
};

```


### 202. Happy Number
```go
func isHappy(n int) bool {
    seen := make (map[int]bool)
    for n!= 1 && !seen[n]{
        seen[n]=true
        sum := 0
        for n>0{
            digit := n % 10;
            sum += digit * digit
            n = sum
        }
    }
    return n==1
}

```


```go
package main

import "fmt"

func isHappy(n int) bool {
    // 定义辅助函数，计算下一个平方和
    getNext := func(num int) int {
        sum := 0
        for num > 0 {
            digit := num % 10
            sum += digit * digit
            num = num / 10
        }
        return sum
    }

    slow, fast := n, getNext(n) // 初始化快慢指针
    for fast != 1 && slow != fast {
        slow = getNext(slow)     // 慢指针走一步
        fast = getNext(getNext(fast)) // 快指针走两步
    }
    return fast == 1
}


``` 

### 219. Contains Duplicate II
```py

class Solution:
    def containsNearbyDuplicate(self, nums: List[int], k: int) -> bool:
        index_map = {}
        for i, num in enumerate(nums):
            if num in index_map:
                if i - index_map[num] <= k:
                    return True
            index_map[num] = i
        
        return False

```


### 128. Longest Consecutive Sequence
```cpp
//buggy
class Solution {
public:
    int longestConsecutive(vector<int>& nums) {
        if (nums.empty()) return 0;
        vector<vector<int>> sequences;
        for(int num: nums){
            bool added = false;
            for(auto& seq : sequences){
                if(seq.back() + 1 == num){
                    seq.push_back(num);
                    added = true;
                }else if (seq.front() - 1 == num){
                    seq.insert(seq.begin(), num);
                    added = true;
                }
            }
            if (!added){
                sequences.push_back({num});
            }

        }
        mergeSequences(sequences);
        int maxLength = 0;
        for (const auto& seq : sequences){
            maxLength = max(maxLength, static_cast<int>(seq.size()));
        }
        return maxLength;
    }
private:
    void mergeSequences(vector<vector<int>>& sequences) {
        bool merged = true; // 标记是否发生了合并

        // 只要发生过合并，就继续尝试合并
        while (merged) {
            merged = false;

            // 标记需要删除的子序列
            vector<bool> toRemove(sequences.size(), false);

            // 遍历每对子序列，检查是否相连
            for (size_t i = 0; i < sequences.size(); ++i) {
                if (toRemove[i]) continue; // 已经标记为删除的子序列跳过

                for (size_t j = i + 1; j < sequences.size(); ++j) {
                    if (toRemove[j]) continue; // 已经标记为删除的子序列跳过

                    const auto& seq1 = sequences[i];
                    const auto& seq2 = sequences[j];

                    // 检查两个子序列是否相连
                    if (seq1.back() + 1 == seq2.front() || seq2.back() + 1 == seq1.front()) {
                        // 合并两个子序列
                        vector<int> mergedSeq;
                        if (seq1.back() + 1 == seq2.front()) {
                            mergedSeq.insert(mergedSeq.end(), seq1.begin(), seq1.end());
                            mergedSeq.insert(mergedSeq.end(), seq2.begin(), seq2.end());
                        } else {
                            mergedSeq.insert(mergedSeq.end(), seq2.begin(), seq2.end());
                            mergedSeq.insert(mergedSeq.end(), seq1.begin(), seq1.end());
                        }

                        // 替换第一个子序列，并标记第二个子序列为删除
                        sequences[i] = mergedSeq;
                        toRemove[j] = true;
                        merged = true; // 标记发生了合并
                    }
                }
            }

            // 移除被标记为删除的子序列
            vector<vector<int>> newSequences;
            for (size_t i = 0; i < sequences.size(); ++i) {
                if (!toRemove[i]) {
                    newSequences.push_back(sequences[i]);
                }
            }

            sequences = move(newSequences);
        }
    }
};
```
```cpp
//TIMEOUT
class Solution {
public:
    int longestConsecutive(vector<int>& nums) {
        if (nums.empty())
            return 0;
        unordered_set<int> numSet(nums.begin(),nums.end());
        int maxLength = 0;
        for (int num : nums){
            if (!numSet.count(num - 1)){
                int currentNum = num;
                int currentStreak = 1;
                while (numSet.count(currentNum + 1)){
                    currentNum += 1;
                    currentStreak += 1;
                }
                maxLength = max(maxLength, currentStreak);
            }
        }
        return maxLength;
    }
};
```
```cpp
class Solution {
public:
    int longestConsecutive(vector<int>& nums) {
        if (nums.empty())
            return 0;
            
        unordered_set<int> numSet(nums.begin(), nums.end());
        
        int maxLength = 0;
        
        for (int num : numSet) {
            if (!numSet.count(num - 1)) {
                int currentNum = num;
                int currentStreak = 1;
                
                while (numSet.count(currentNum + 1)) {
                    currentNum += 1;
                    currentStreak += 1;
                }
                
                maxLength = max(maxLength, currentStreak);
            }
        }
        
        return maxLength;
    }
};
```
### 228. Summary Ranges

```cpp
class Solution {
public:
    vector<string> summaryRanges(vector<int>& nums) {
        vector<string> result;
        if (nums.empty()) return result;
        int start = nums[0], end = nums[0];
        for (int i = 1; i <= nums.size(); ++i){
            if (i < nums.size() && nums[i] == end + 1){
                end = nums[i];
            }else{
                if (start == end){
                    result.push_back(to_string(start));
                }else{
                    result.push_back(to_string(start)+"->"+to_string(end));
                }
                if(i<nums.size()){
                    start = end = nums[i];
                }
            }
        }
        return result;
    }
};
```

### 56. Merge Intervals
```go
package main

import (
    "fmt"
    "sort"
)

func merge(intervals [][]int) [][]int {
    sort.Slice(intervals,func(i,j int) bool {
        return intervals[i][0] < intervals[j][0]
    })
    var merged [][]int

    for _, interval := range intervals{
        if len(merged) == 0 || merged[len(merged)-1][1] < interval[0]{
            merged = append(merged,interval)
        }else{
            merged[len(merged)-1][1] = max(merged[len(merged)-1][1],interval[1])
        }
    }

    return merged
}

func max(a,b int) int {
    if a > b{
        return a
    }
    return b
}
```


### 57. Insert Interval

```py
class Solution:
    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:
        result = []
        i = 0
        n = len(intervals)

        while i<n and intervals[i][1]<newInterval[0]:
            result.append(intervals[i])
            i+=1

        while i<n and intervals[i][0]<=newInterval[1]:
            newInterval[0]=min(newInterval[0],intervals[i][0])
            newInterval[1]=max(newInterval[1],intervals[i][1])
            i += 1
        result.append(newInterval)

        while i<n:
            result.append(intervals[i])
            i+=1

        return result


        

```

### 452. Minimum Number of Arrows to Burst Balloons

```py
class Solution:
    def findMinArrowShots(self, points: List[List[int]]) -> int:
        if not points:
            return 0
        points.sort(key=lambda x:x[1])
        arrows=1
        current_end=points[0][1]

        for i in range(1,len(points)):
            if points[i][0]>current_end:
                arrows += 1
                current_end = points[i][1]
        
        return arrows



```

### 20. Valid Parentheses

```py
# 408常见题目
class Solution:
    def isValid(self, s: str) -> bool:
        stack = []
        paren_map = {')':'(','}':'{',']':'['}

        for char in s:
            if char in paren_map:
                if not stack:
                    return False
                if stack.pop() != paren_map[char]:
                    return False
            else:
                stack.append(char)
        return not stack


```


### 71. Simplify Path

```py

class Solution:
    def simplifyPath(self, path: str) -> str:
        parts = path.split("/")
        stack = []

        for part in parts
            if part == "" or part == ".":
                continue
            elif part == ".."
                if stack:
                stack.pop()
            else:
                stack.append(part)
        result = "/" + "/".join(stack)
        return result
```



### 155. Min Stack

```py

class MinStack:
    def __init__(self):
        self.stack = []        # 主栈
        self.min_stack = []    # 辅助栈，存储最小值

    def push(self, val: int) -> None:
        self.stack.append(val)
        # 如果辅助栈为空，或当前值 <= 辅助栈顶，则压入辅助栈
        if not self.min_stack or val <= self.min_stack[-1]:
            self.min_stack.append(val)

    def pop(self) -> None:
        # 如果弹出的元素是当前最小值，辅助栈也弹出
        if self.stack.pop() == self.min_stack[-1]:
            self.min_stack.pop()

    def top(self) -> int:
        return self.stack[-1]

    def getMin(self) -> int:
        return self.min_stack[-1]


# Your MinStack object will be instantiated and called as such:
# obj = MinStack()
# obj.push(val)
# obj.pop()
# param_3 = obj.top()
# param_4 = obj.getMin()
```




### 150. Evaluate Reverse Polish Notation
```py

class Solution:
    def evalRPN(self, tokens: List[str]) -> int:
        stack = []
        for token in tokens:
            if token in "+-*/":
                a = stack.pop()
                b = stack.pop()
                if token == '+':
                    stack.append(b+a)
                elif token == '-':
                    stack.append(b-a)
                elif token == '*':
                    stack.append(b*a)
                elif token == '/':
                    stack.append(int(b/a))
            else:
                stack.append(int(token))
        return stack.pop()
```


### 224. Basic Calculator

```py
class Solution:
    def calculate(self, s: str) -> int:
        stack = []
        current_result = 0
        sign = 1 #pos/neg
        i = 0
        n = len(s)

        while i < n:
            if s[i] == ' ' :
                i += 1
            elif s[i] == '+':
                sign = 1
                i += 1
            elif s[i] == '-':
                sign = -1
                i += 1
            elif s[i] == '(':
                stack.append(current_result)
                stack.append(sign)
                current_result = 0
                sign = 1
                i += 1
            elif s[i] == ')':
                prev_sign = stack.pop()
                prev_result = stack.pop()
                current_result = prev_result + prev_sign * current_result
                i += 1
            else:
                num = 0
                while i < n and s[i].isdigit():
                    num = num * 10 + int(s[i])
                    i += 1
                current_result += num * sign
        return current_result

```

### 141. Linked List Cycle

```py


# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def hasCycle(self, head: Optional[ListNode]) -> bool:
        slow, fast = head, head
        
        while fast and fast.next:
            slow = slow.next
            fast = fast.next.next
            if slow == fast:
                return True
        return False

```
