### 88. Merge Sorted Array
```python
class Solution:
    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:
        """
        Do not return anything, modify nums1 in-place instead.
        """
        # 两个数列各一指针
        i = m - 1
        j = n - 1
        # 用于写入的辅助指针
        k = m + n - 1

        while i >= 0 and j >= 0:
            if nums1[i] > nums2[j]:
                nums1[k] = nums1[i]
                i -= 1
            else:
                nums1[k] = nums2[j]
                j -= 1
            k -= 1
        
        # 如果nums1的有效长度短，nums2剩下的部分就直接覆盖前面那部分
        while j>= 0:
            nums1[k] = nums2[j]
            j -= 1
            k -= 1

        # 如果nums2的有效长度短，那到这已经完美不需要处理了
        
```

```python
# 暴力解法
class Solution:
    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:
        """
        Do not return anything, modify nums1 in-place instead.
        """
        # 将 nums2 的元素直接复制到 nums1 的后半部分
        for i in range(n):
            nums1[m + i] = nums2[i]
        
        # 对整个 nums1 进行排序
        nums1.sort()
```

```cpp
//暴力解法
class Solution {
public:
    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {
        for (int i = 0; i < n; ++i) {
            nums1[i + m] = nums2[i];
        }
        std::sort(nums1.begin(), nums1.end()); //标准库函数，使用半开区间概念
    }
};

```

### 27. Remove Element
```python
class Solution:
    def removeElement(self, nums: List[int], val: int) -> int:
        k=0    # 慢指针
        # 很简单，就是利用双指针，有命中的时候辅助指针不自增，
        # 等着循环指针前移后，利用后面的前移步骤洗掉这个命中位置的元素
        for i in range(len(nums)):
            if nums[i] != val:
                if i != k:
                # 例：如果本身就是1357000，匹配2，那就没必要移动
                    nums[k] = nums[i]
                    # 把原本在后面的元素移到k的位置
                k += 1
        return k
```
```python
class Solution:
    def removeElement(self, nums: List[int], val: int) -> int:
        i = 0
        j = len(nums) - 1
        # 在某些情况下（例如数组中有很多等于 val 的元素）可能会更快，
        # 因为直接跳过了这些元素，而不需要逐一检查。
        # 但顺序会乱，因为尾部的元素被移动到了前面
        while i <= j:
            if nums[i] == val:
                nums[i] = nums[j]  # 用尾部元素替换
                j -= 1  # 尾部指针左移
            else:
                i += 1  # 头部指针右移
        
        return i
```
```python
class Solution:
    def removeElement(self, nums: List[int], val: int) -> int:
        # 使用列表推导式生成新数组
        filtered_nums = [x for x in nums if x != val]
        # 将结果写回原数组
        for i in range(len(filtered_nums)):
            nums[i] = filtered_nums[i]
        return len(filtered_nums)
```

```cpp
class Solution {
public:
    int removeElement(vector<int>& nums, int val) {
        std ::vector<int> temp; //temp arry
        for (int num : nums){
            if (num != val){
                temp.push_back(num);//or we can use push_front() in a std::<int> dq scenario
            }
        }
        nums = temp;
        return temp.size();
    }
};
```

### 26. Remove Duplicates from Sorted Array
```cpp
class Solution {
public:
    int removeDuplicates(vector<int>& nums) {
        if (nums.empty()) return 0; //判空

        int i = 0; //慢指针
        for (int j = 1; j < nums.size(); ++j){
            if (nums[j] != nums[i]){//若正常非重复，后面i会正常自增
                ++i;
                if (i != j){ //ij两个指针有错位时才进行赋值
                    nums[i] = nums[j]; 
                }
            }
        }
        return i + 1;
    }
};
```

```cpp
//暴力解法
class Solution {
public:
    int removeDuplicates(vector<int>& nums) {
        if(nums.empty()  )  return 0;
        
        vector<int> unique_nums;
        unique_nums.push_back(nums[0]);

        for (int i = 1; i < nums.size(); ++ i){
            if(nums[i] != unique_nums.back()){
                unique_nums.push_back(nums[i]);
            }
        }

        for (int i = 0; i < unique_nums.size(); ++i){
            nums [i] = 0;
        }

        for (int i = 0; i < unique_nums.size(); ++i){
            nums [i] = unique_nums[i];
        }

        return unique_nums.size();
    }
};

```

### 80. Remove Duplicates from Sorted Array II
```cpp
class Solution {
public:
    int removeDuplicates(vector<int>& nums) {
        if (nums.size() <= 2) return  nums.size(); //数组长度小于等于2，直接返回长度
        int i = 2; //可以理解为慢指针，初始值为2（前两个元素一定符合条件）
        for(int j = 2; j < nums.size(); ++j){//从第3个元素开始遍历
            if (nums[j] != nums[i-2]){//如果当前元素与前两个不一样，就往前挪
                                      //如果一样，就不进来，让慢指针站着
                nums[i] = nums[j];  //挪
                i += 1;
            }
        }
        return i;
    }
};
```
```cpp
//一样，一些小更改
class Solution {
public:
    int removeDuplicates(vector<int>& nums) {
        if (nums.size() <= 2) return nums.size(); // 数组长度小于等于2，直接返回长度
        
        int i = 2; // 慢指针，初始值为2（前两个元素一定符合条件）
        int n = nums.size(); // 避免重复调用 nums.size()
        
        for (int j = 2; j < n; ++j) { // 从第3个元素开始遍历
            if (nums[j] != nums[i - 2]) { // 如果当前元素与前两个不一样
                nums[i++] = nums[j]; // 直接赋值并递增慢指针
            }
        }
        return i; // 返回符合条件的元素个数
    }
};
```

```cpp
//暴力解法
class Solution {
public:
    int removeDuplicates(vector<int>& nums) {
        int size = nums.size();
        vector<int> temp;

        if (size <= 2) return size;

        temp.push_back(nums[0]);
        temp.push_back(nums[1]);

        for(int i = 2; i < size; ++i){
            if(nums[i] != temp[temp.size()-2]){
                temp.push_back(nums[i]);
            }
        }
        for(int i = 0; i < temp.size(); ++i){
            nums[i] = temp[i];
        }
        return temp.size();
    }
};

```

### 169. Majority Element
```cpp
class Solution {
public:
    int majorityElement(vector<int>& nums) {
        //用摩尔投票算法（抵消机制）
        int candidate = 0;
        int count = 0;
        for (int num : nums) {
            if （count == 0) {
                candidate = num;
            }
            count += (num == candidate) ? 1: -1;
        }
        return candidate;
        //同+异-，到0就换人，最后没被-到0的就是正确candidate
    }
};

```

```cpp
//暴力解法
class Solution {
public:
    int majorityElement(vector<int>& nums) {
        int size = nums.size();
        for(int num : nums){
            int count = 0;
            for (int other : nums){
                if(num == other){
                    ++count;
                }
            }
            if(count> size/2){
                return num;
            }
        }
        return -1;
    }
};
```

### 189. Rotate Array

<!-- 
<img width="241" alt="{82C08DFF-EE2C-44CA-BC51-9CF36696EEB6}" src="https://github.com/user-attachments/assets/9b6ed2ae-c6d6-43e3-9ee5-3b3eb28ed7bf" />
<img width="241" alt="{4F6C9CBF-38CD-47C7-AD21-0371340FCA83}" src="https://github.com/user-attachments/assets/3c15ce2a-3fa3-47ea-b8f6-0c98c425788a" />
<img width="483" alt="{55730CE6-D344-4739-8F8C-784572E7160F}" src="https://github.com/user-attachments/assets/0986152a-423b-4962-a530-7b6d028053a3" />
-->

#### 示例：
假设我们有一个数组 `nums = [1, 2, 3, 4, 5, 6]`，并且 `k = 2`。我们的目标是将数组向右旋转 2 个位置。

##### 初始数组：
```
[1, 2, 3, 4, 5, 6]
```

##### 旋转后的目标数组：
```
[5, 6, 1, 2, 3, 4]
```

#### 算法执行过程：

##### 第一步：初始化
- 数组长度 `n = 6`。
- `k = k % n = 2 % 6 = 2`。
- 定义计数器 `count = 0`，用于记录已经处理过的元素数量。
- 外层循环从 `start = 0` 开始。

##### 第二步：处理第一个环
1. **外层循环**：`start = 0`，表示从索引 `0` 开始处理。
   - `current = start = 0`，`prev = nums[0] = 1`。
   
2. **内层循环**（`do-while`）：
   - **第一次迭代**：
     - 计算下一个位置：`next = (current + k) % n = (0 + 2) % 6 = 2`。
     - 保存目标位置的值：`temp = nums[next] = nums[2] = 3`。
     - 将当前值放到目标位置：`nums[next] = prev = 1`。
     - 更新 `prev = temp = 3`。
     - 更新 `current = next = 2`。
     - 增加计数器：`count++`，现在 `count = 1`。
     
     当前数组状态：
     ```
     [1, 2, 1, 4, 5, 6]
     ```

   - **第二次迭代**：
     - 计算下一个位置：`next = (current + k) % n = (2 + 2) % 6 = 4`。
     - 保存目标位置的值：`temp = nums[next] = nums[4] = 5`。
     - 将当前值放到目标位置：`nums[next] = prev = 3`。
     - 更新 `prev = temp = 5`。
     - 更新 `current = next = 4`。
     - 增加计数器：`count++`，现在 `count = 2`。
     
     当前数组状态：
     ```
     [1, 2, 1, 4, 3, 6]
     ```

   - **第三次迭代**：
     - 计算下一个位置：`next = (current + k) % n = (4 + 2) % 6 = 0`。
     - 保存目标位置的值：`temp = nums[next] = nums[0] = 1`。
     - 将当前值放到目标位置：`nums[next] = prev = 5`。
     - 更新 `prev = temp = 1`。
     - 更新 `current = next = 0`。
     - 增加计数器：`count++`，现在 `count = 3`。
     
     当前数组状态：
     ```
     [5, 2, 1, 4, 3, 6]
     ```

   - **退出内层循环**：此时 `current == start`，即回到了起始位置 `0`，表示这个环已经处理完毕。

##### 第三步：处理第二个环
1. **外层循环**：`start = 1`，表示从索引 `1` 开始处理。
   - `current = start = 1`，`prev = nums[1] = 2`。

2. **内层循环**（`do-while`）：
   - **第一次迭代**：
     - 计算下一个位置：`next = (current + k) % n = (1 + 2) % 6 = 3`。
     - 保存目标位置的值：`temp = nums[next] = nums[3] = 4`。
     - 将当前值放到目标位置：`nums[next] = prev = 2`。
     - 更新 `prev = temp = 4`。
     - 更新 `current = next = 3`。
     - 增加计数器：`count++`，现在 `count = 4`。
     
     当前数组状态：
     ```
     [5, 2, 1, 2, 3, 6]
     ```

   - **第二次迭代**：
     - 计算下一个位置：`next = (current + k) % n = (3 + 2) % 6 = 5`。
     - 保存目标位置的值：`temp = nums[next] = nums[5] = 6`。
     - 将当前值放到目标位置：`nums[next] = prev = 4`。
     - 更新 `prev = temp = 6`。
     - 更新 `current = next = 5`。
     - 增加计数器：`count++`，现在 `count = 5`。
     
     当前数组状态：
     ```
     [5, 2, 1, 2, 3, 4]
     ```

   - **第三次迭代**：
     - 计算下一个位置：`next = (current + k) % n = (5 + 2) % 6 = 1`。
     - 保存目标位置的值：`temp = nums[next] = nums[1] = 2`。
     - 将当前值放到目标位置：`nums[next] = prev = 6`。
     - 更新 `prev = temp = 2`。
     - 更新 `current = next = 1`。
     - 增加计数器：`count++`，现在 `count = 6`。
     
     当前数组状态：
     ```
     [5, 6, 1, 2, 3, 4]
     ```

   - **退出内层循环**：此时 `current == start`，即回到了起始位置 `1`，表示这个环已经处理完毕。

##### 第四步：结束
- 此时 `count == n`，所有元素都已经被处理完毕，算法结束。

#### 最终结果：
```
[5, 6, 1, 2, 3, 4]
```

#### 总结：
在这个例子中，数组被分成了两个环：
1. 第一个环：`1 -> 3 -> 5 -> 1`。
2. 第二个环：`2 -> 4 -> 6 -> 2`。

外层循环负责确保每个环都被处理，而内层循环则在一个环内完成元素的旋转。通过这种方式，算法高效地完成了数组的旋转操作。
```cpp
class Solution {
public:
    void rotate(vector<int>& nums, int k) {
        int n = nums.size(); //
        k = k % n;
        int count = 0; //当 count 达到数组的长度 n 时，说明所有元素都已经完成了旋转。
        for (int start = 0; count < n; ++start){
            int current =start; //当前正在处理的元素的索引
            int prev =nums[start]; //当前元素的值

            do{
                int next = (current + k) % n; //计算当前元素应该移动到的目标位置。
                int temp = nums[next]; //保存目标位置的原始值。
                nums[next]=prev; //将当前元素的值放到目标位置。
                prev = temp; //更新 prev 为刚才保存的目标位置的原始值，以便下一次循环使用。
                current = next; //更新 current 为下一个要处理的索引。
                count++;
            }while(start != current); //当 current 回到起始位置 start 时，表示这个“环”内的所有元素都已经被处理完
        }
    }
};
```

```cpp
class Solution {
public:
    void rotate(vector<int>& nums, int k) {
        int n = nums.size();
        k = k % n;
        reverse(nums.begin(),nums.end());
        reverse(nums.begin(),nums.begin()+k);
        reverse(nums.begin()+k,nums.end());
    }
};
```
```cpp

//暴力
class Solution {
public:
    void rotate(vector<int>& nums, int k) {
        int size = nums.size();
        int step = k % size;
        vector<int> front_nums(step);
        vector<int> back_nums(size-step);
        for(int i=0; i<step; ++i){
            front_nums[i]=nums[size-step+i];
        }
        for(int i=0; i<size-step; ++i){
            back_nums[i]=nums[i];
        }
        for(int i=0; i<size; ++i){
            if(i<step){
                nums[i]=front_nums[i];
            }
            else{
                nums[i]=back_nums[i-step];
            }
        }
    }
};
```

### 121. Best Time to Buy and Sell Stock

```cpp
//暴力
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int size = prices.size();
        int profit = 0;
        for(int i = 0; i < size; ++i){
            int buy = prices[i];
            for(int j = i + 1; j < size; ++j){
                int sell = prices[j];
                if((sell - buy)>profit){
                    profit = sell - buy;
                }
            }
        }
        return profit;
    }
};
```
```cpp
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int buy = INT_MAX;
        int profit = 0;
        for (int price : prices){
            if (price < buy){
                buy = price;
            }
            else{
                profit = max(profit, price - buy);
            }
        }
        return profit;
    }

};

```

```cpp
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int size = prices.size();
        if (size <= 1) return 0;

        int min_price = INT_MAX;
        int profit = 0; 

        for (int i = 1; i < size; ++i) {
            min_price = min(prices[i-1],min_price);
            profit = max(prices[i] - min_price, profit);
        }

        return profit;
    }
};

```
### 122. Best Time to Buy and Sell Stock II
```cpp
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        //贪心算法
        int max_profit = 0;
        for(int i = 1; i  < prices.size(); ++i){
            if (prices[i] > prices[i-1]){
               max_profit +=  (prices[i] - prices[i-1]);
            }
        }
        return max_profit;
    }
};
```

### 55. Jump Game

```cpp
class Solution {
public:
    bool canJump(vector<int>& nums) {
        if (nums.size() == 1) {
            return true;
        }
        int max_reach = 0;
        for(int i=0;i<nums.size();++i){
            if(i > max_reach){
                return false;
            }
            max_reach = max(nums[i]+i,max_reach);
            if((max_reach>=nums.size()-1)){
                return true;
            }
        }
        return false;
    }
};
```

### 45. Jump Game II
```cpp
class Solution {
public:
    int jump(vector<int>& nums) {
        //贪心算法
        if(nums.size() == 1) return 0;
        int jumps = 0;
        int current_end = 0;
        int most_far = 0;
        for(int i = 0; i<nums.size()-1; ++i){
            most_far = max(i + nums[i],most_far);
            if(i == current_end){
                ++jumps;
                current_end = most_far;
            }
            if(current_end>=nums.size()-1){
                break;
            }
        }
        return jumps;
    }
};
```

---

#### 动态规划的核心思想

动态规划是一种通过将问题分解为子问题，并存储子问题的解来避免重复计算的方法。在本题中，动态规划的核心思想是：
- **定义状态**：用 `dp[i]` 表示从索引 `i` 到达终点所需的最小跳跃次数。
- **状态转移方程**：通过递推关系，从已知的状态推导出未知的状态。
- **初始条件**：明确一些已知的状态（如终点的状态）。
- **最终目标**：求解 `dp[0]`，即从起点到达终点的最小跳跃次数。

---

#### 代码逐步解析

##### 1. 初始化
```cpp
int n = nums.size();
vector<int> dp(n, INT_MAX);  // dp[i] 表示从索引 i 到达终点的最小跳跃次数
dp[n - 1] = 0;               // 最后一个位置无需跳跃
```

- **`dp` 数组**：
  - `dp[i]` 表示从索引 `i` 到达终点所需的最小跳跃次数。
  - 初始时，所有位置的跳跃次数都设为 `INT_MAX`，表示尚未计算。
  
- **初始条件**：
  - 终点（最后一个位置）不需要跳跃，因此 `dp[n-1] = 0`。

---

##### 2. 自底向上填充 `dp` 数组
```cpp
for (int i = n - 2; i >= 0; --i) {
    int max_step = nums[i];
    for (int step = 1; step <= max_step && i + step < n; ++step) {
        dp[i] = min(dp[i], 1 + dp[i + step]);
    }
}
```

这段代码是动态规划的核心部分，我们逐行分析：

###### (1) 外层循环
```cpp
for (int i = n - 2; i >= 0; --i)
```
- 从倒数第二个位置开始向前遍历数组。
- 因为终点的状态已经确定（`dp[n-1] = 0`），所以从 `n-2` 开始向前推导。

###### (2) 当前位置的最大跳跃步数
```cpp
int max_step = nums[i];
```
- `nums[i]` 表示从索引 `i` 出发能够跳跃的最大步数。
- 这决定了我们可以尝试的所有跳跃目标位置。

###### (3) 内层循环：尝试所有可能的跳跃目标
```cpp
for (int step = 1; step <= max_step && i + step < n; ++step) {
    dp[i] = min(dp[i], 1 + dp[i + step]);
}
```
- **内层循环的作用**：
  - 从当前位置 `i` 出发，尝试跳到 `[i+1, i+max_step]` 中的所有位置。
  - 对于每个目标位置 `i + step`，计算从 `i` 跳到 `i + step` 所需的跳跃次数。

- **状态转移方程**：
  - 如果从 `i` 跳到 `i + step`，那么总的跳跃次数为 `1 + dp[i + step]`。
  - 我们取所有可能的目标位置中的最小值，更新 `dp[i]`。

- **边界条件**：
  - 确保目标位置 `i + step` 不超出数组边界（`i + step < n`）。

---

##### 3. 返回结果
```cpp
return dp[0];  // 返回从起点到达终点的最小跳跃次数
```
- 最终，`dp[0]` 存储了从起点（索引 `0`）到达终点（索引 `n-1`）所需的最小跳跃次数。

---

#### 动态规划的直观理解

为了更好地理解动态规划的过程，我们可以通过一个具体的例子来模拟。

##### 示例：`nums = [2, 3, 1, 1, 4]`

1. **初始化**：
   - `dp = [INT_MAX, INT_MAX, INT_MAX, INT_MAX, 0]`
   - 因为终点（索引 `4`）无需跳跃，所以 `dp[4] = 0`。

2. **从后往前填充 `dp` 数组**：

   - **索引 3**：
     - `nums[3] = 1`，最大跳跃步数为 1。
     - 目标位置：`3 + 1 = 4`。
     - 更新：`dp[3] = min(dp[3], 1 + dp[4]) = min(INT_MAX, 1 + 0) = 1`。
     - `dp = [INT_MAX, INT_MAX, INT_MAX, 1, 0]`

   - **索引 2**：
     - `nums[2] = 1`，最大跳跃步数为 1。
     - 目标位置：`2 + 1 = 3`。
     - 更新：`dp[2] = min(dp[2], 1 + dp[3]) = min(INT_MAX, 1 + 1) = 2`。
     - `dp = [INT_MAX, INT_MAX, 2, 1, 0]`

   - **索引 1**：
     - `nums[1] = 3`，最大跳跃步数为 3。
     - 目标位置：`1 + 1 = 2`，`1 + 2 = 3`，`1 + 3 = 4`。
     - 更新：
       - `dp[1] = min(dp[1], 1 + dp[2]) = min(INT_MAX, 1 + 2) = 3`
       - `dp[1] = min(dp[1], 1 + dp[3]) = min(3, 1 + 1) = 2`
       - `dp[1] = min(dp[1], 1 + dp[4]) = min(2, 1 + 0) = 1`
     - `dp = [INT_MAX, 1, 2, 1, 0]`

   - **索引 0**：
     - `nums[0] = 2`，最大跳跃步数为 2。
     - 目标位置：`0 + 1 = 1`，`0 + 2 = 2`。
     - 更新：
       - `dp[0] = min(dp[0], 1 + dp[1]) = min(INT_MAX, 1 + 1) = 2`
       - `dp[0] = min(dp[0], 1 + dp[2]) = min(2, 1 + 2) = 2`
     - `dp = [2, 1, 2, 1, 0]`

3. **最终结果**：
   - `dp[0] = 2`，表示从起点到达终点的最小跳跃次数为 2。

---

#### 动态规划的复杂度分析

1. **时间复杂度**：
   - 外层循环遍历数组的所有位置，时间复杂度为 $O(n)$。
   - 内层循环尝试所有可能的跳跃目标，最坏情况下需要 $O(n)$ 次操作。
   - 总时间复杂度为 $O(n^2)$。

2. **空间复杂度**：
   - 使用了一个大小为 $n$ 的 `dp` 数组，空间复杂度为 $O(n)$。

---

#### 总结

1. **动态规划的核心思想**：
   - 定义状态 `dp[i]`，表示从索引 `i` 到达终点的最小跳跃次数。
   - 通过状态转移方程，从已知的状态推导出未知的状态。

2. **实现步骤**：
   - 初始化 `dp` 数组。
   - 从后往前填充 `dp` 数组，利用状态转移方程更新每个位置的最小跳跃次数。
   - 返回 `dp[0]`，即从起点到达终点的最小跳跃次数。

3. **优点与局限性**：
   - 动态规划适合解决具有最优子结构性质的问题。
   - 但其时间复杂度较高（$O(n^2)$），对于大规模数据可能不如贪心算法高效。

```cpp
class Solution {
public:
    int jump(vector<int>& nums) {
        //动态规划
        if (nums.empty()) {
            return 0; 
        }

        int size = nums.size();
        vector<long long int> dp(size,INT_MAX);
        dp[size-1]=0;

        for(int i = size-2; i >= 0; --i){
            int max_step = nums[i];
            for(int step = 1; step <= max_step && i + step < size; ++ step){
                dp[i]=min(dp[i],1+dp[i+step]);
            }
        }
        return dp[0];
    }
};
```


### 274. H-Index
```cpp
class Solution {
public:
    int hIndex(vector<int>& citations) {
        std::sort(citations.begin(),citations.end(),std::greater<int>());

        int h=0;
        for (int i = 0; i < citations.size(); ++i){
            if(citations[i] >= i + 1){
                h = i + 1; //h-index 是由 论文数量 和 引用次数 共同决定,因为排过序所以篇数有规律
            }else{
                break;
            }
        }
        return h;
    }
};
```


### 380. Insert Delete GetRandom O(1)

```cpp
class RandomizedSet {
private:
    std::vector<int> nums;
    std::unordered_map<int, int> val_to_index;
public:
    RandomizedSet() {
        
    }
    
    bool insert(int val) {
        if(val_to_index.find(val) != val_to_index.end()){
            return false;
        }
        val_to_index[val]=nums.size();
        nums.push_back(val);

        return true;
    }
    
    bool remove(int val) {
        if(val_to_index.find(val) == val_to_index.end()){
            return false;
        }
        int index = val_to_index[val];
        int last_element = nums.back();
        nums[index] = last_element;
        val_to_index[last_element] = index;
        nums.pop_back();
        val_to_index.erase(val);
        return true;
    }
    
    int getRandom() {   
        int random_index = rand() % nums.size();
        return nums[random_index];
        
    }
};

/**
 * Your RandomizedSet object will be instantiated and called as such:
 * RandomizedSet* obj = new RandomizedSet();
 * bool param_1 = obj->insert(val);
 * bool param_2 = obj->remove(val);
 * int param_3 = obj->getRandom();
 */

```





#### 类的定义

```cpp
class RandomizedSet {
private:
    std::vector<int> nums;
    std::unordered_map<int, int> val_to_index;
```

- `std::vector<int> nums;`：这是一个动态数组，用于存储集合中的所有元素。
- `std::unordered_map<int, int> val_to_index;`：这是一个哈希表（无序映射），用于存储每个元素在 `nums` 数组中的索引。键是元素值，值是该元素在 `nums` 中的索引。

#### 构造函数

```cpp
public:
    RandomizedSet() {
        
    }
```

- 这是 `RandomizedSet` 类的构造函数，初始化时不需要做任何事情，因为 `nums` 和 `val_to_index` 都会自动初始化为空。

#### 插入操作

```cpp
    bool insert(int val) {
        if(val_to_index.find(val) != val_to_index.end()){
            return false;
        }
        val_to_index[val] = nums.size();
        nums.push_back(val);
        return true;
    }
```

- `if(val_to_index.find(val) != val_to_index.end())`：首先检查 `val` 是否已经存在于 `val_to_index` 中。如果存在，说明该值已经在集合中，返回 `false` 表示插入失败。
- `val_to_index[val] = nums.size();`：如果 `val` 不存在于集合中，则将其插入到 `nums` 数组的末尾，并在 `val_to_index` 中记录它的索引。`nums.size()` 是当前数组的大小，也就是新元素将要插入的位置。
- `nums.push_back(val);`：将 `val` 添加到 `nums` 数组的末尾。
- `return true;`：返回 `true` 表示插入成功。

#### 删除操作

```cpp
    bool remove(int val) {
        if(val_to_index.find(val) == val_to_index.end()){
            return false;
        }
        int index = val_to_index[val];
        int last_element = nums.back();
        nums[index] = last_element;
        val_to_index[last_element] = index;
        nums.pop_back();
        val_to_index.erase(val);
        return true;
    }
```

- `if(val_to_index.find(val) == val_to_index.end())`：首先检查 `val` 是否存在于 `val_to_index` 中。如果不存在，返回 `false` 表示删除失败。
- `int index = val_to_index[val];`：获取 `val` 在 `nums` 数组中的索引。
- `int last_element = nums.back();`：获取 `nums` 数组的最后一个元素。
- `nums[index] = last_element;`：将 `nums` 数组的最后一个元素移动到 `val` 所在的位置，覆盖掉 `val`。
- `val_to_index[last_element] = index;`：更新 `val_to_index` 中最后一个元素的索引为 `val` 原来的索引。
- `nums.pop_back();`：从 `nums` 数组中移除最后一个元素。
- `val_to_index.erase(val);`：从 `val_to_index` 中删除 `val` 的记录。
- `return true;`：返回 `true` 表示删除成功。

#### 获取随机元素

```cpp
    int getRandom() {   
        int random_index = rand() % nums.size();
        return nums[random_index];
    }
```

- `int random_index = rand() % nums.size();`：生成一个从 `0` 到 `nums.size() - 1` 的随机索引。
- `return nums[random_index];`：返回 `nums` 数组中对应随机索引位置的元素。

#### 总结

```cpp
/**
 * Your RandomizedSet object will be instantiated and called as such:
 * RandomizedSet* obj = new RandomizedSet();
 * bool param_1 = obj->insert(val);
 * bool param_2 = obj->remove(val);
 * int param_3 = obj->getRandom();
 */
```

- 这段注释说明了如何使用 `RandomizedSet` 类。你可以创建一个 `RandomizedSet` 对象，并调用其 `insert`、`remove` 和 `getRandom` 方法来执行相应的操作。

#### 关键点总结：
1. **插入**：通过 `unordered_map` 快速判断元素是否存在，若不存在则插入到 `vector` 的末尾，并更新 `unordered_map`。
2. **删除**：通过 `unordered_map` 快速定位要删除的元素，然后将数组末尾的元素移到要删除元素的位置，最后删除末尾元素并更新 `unordered_map`。
3. **获取随机元素**：通过 `rand()` 函数生成随机索引，直接访问 `vector` 中的元素。

这个设计确保了插入、删除和获取随机元素的时间复杂度都是 O(1)。



---

#### **1. 数据的来源：反复调用操作**
在这道题中，数据的来源并不是预先定义好的，而是通过 **反复调用类的方法**（`insert`、`remove` 和 `getRandom`）动态生成和管理的。换句话说：
- 你创建了一个 `RandomizedSet` 对象。
- 然后通过调用 `insert` 方法插入数据。
- 再通过 `remove` 方法删除数据。
- 最后通过 `getRandom` 方法随机获取数据。

这些方法的操作会动态地修改类的成员变量（`nums` 和 `val_to_index`），从而形成一个动态的数据集合。

---

#### **2. 示例运行流程**
假设我们按照以下步骤调用方法：

```cpp
RandomizedSet* obj = new RandomizedSet(); // 创建对象

bool param_1 = obj->insert(1); // 插入 1，返回 true
bool param_2 = obj->insert(2); // 插入 2，返回 true
bool param_3 = obj->insert(1); // 再次插入 1，返回 false（因为 1 已存在）

int param_4 = obj->getRandom(); // 随机返回 1 或 2

bool param_5 = obj->remove(1); // 删除 1，返回 true
bool param_6 = obj->remove(3); // 删除 3，返回 false（因为 3 不存在）

int param_7 = obj->getRandom(); // 随机返回 2（此时集合中只有 2）
```

在这个过程中：
- 数据是通过 `insert` 方法逐步添加到集合中的。
- 数据的状态（即 `nums` 和 `val_to_index` 的内容）随着每次调用方法而动态变化。

---

#### **3. 类的设计与数据的动态管理**
这道题的核心思想是设计一个类，使得它能够动态地管理数据，并支持高效的插入、删除和随机获取操作。具体来说：
- **插入**：将新值添加到集合中。
- **删除**：从集合中移除某个值。
- **随机获取**：从集合中随机选择一个值。

所有这些操作都依赖于类的成员变量（`nums` 和 `val_to_index`），它们在每次调用方法时被更新。

---

#### **4. 成员变量的作用**
为了更好地理解数据的动态管理，我们可以回顾一下两个成员变量的作用：
1. **`nums`（动态数组）**：
   - 存储集合中的所有元素。
   - 支持随机访问（用于 `getRandom` 操作）。
   - 支持尾部插入和删除（用于 `insert` 和 `remove` 操作）。

2. **`val_to_index`（哈希表）**：
   - 记录每个值在 `nums` 中的索引。
   - 支持快速查找（用于检查某个值是否存在）。
   - 支持快速更新（用于删除操作时交换元素）。

这两个成员变量共同协作，确保了插入、删除和随机获取操作的时间复杂度均为 O(1)。

---

#### **5. 数据的生命周期**
数据的生命周期可以分为以下几个阶段：
1. **初始化**：
   - 当你创建 `RandomizedSet` 对象时，`nums` 和 `val_to_index` 被初始化为空。

2. **动态更新**：
   - 每次调用 `insert` 方法时，`nums` 和 `val_to_index` 会被更新。
   - 每次调用 `remove` 方法时，`nums` 和 `val_to_index` 也会被更新。

3. **销毁**：
   - 当 `RandomizedSet` 对象被销毁时，`nums` 和 `val_to_index` 也会被自动清理。

---

#### **6. 总结**
- 数据的来源是通过 **反复调用类的方法** 动态生成的。
- 类的成员变量（`nums` 和 `val_to_index`）负责存储和管理数据。
- 每次调用方法时，数据的状态会发生变化，从而形成一个动态的数据集合。

### 238. Product of Array Except Self
```cpp
//暴力
class Solution {
public:
    vector<int> productExceptSelf(vector<int>& nums) {
        vector<int> products(nums.size(),1);
        for(int i = 0; i <= nums.size() - 1; ++i){
            int product = 1;
            for(int j = 0; j <= nums.size() - 1; ++j){
                if(j != i){
                    product *= nums[j];
                }
                products[i] = product;
            }
        }
        return products;
    }
};
```


```cpp
class Solution {
public:
    vector<int> productExceptSelf(vector<int>& nums) {
        int n = nums.size();
        vector<int> result(n, 1); // 全初始化为 1
        int prefix = 1;
        //result[i] = (nums[0] * nums[1] * ... * nums[i-1]) * 
        //(nums[i+1] * nums[i+2] * ... * nums[n-1])
        for (int i = 0; i < n; ++i) {
            result[i] = prefix;
            prefix *= nums[i];
        }
        int suffix = 1;
        for (int i = n - 1; i >= 0; --i) {
            result[i] *= suffix;
            suffix *= nums[i];
        }
        return result;
    }
};


```


### 134. Gas Station
```cpp
//暴力
class Solution {
public:
    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {
        int n = gas.size();
        vector<int> tank_gas(gas.size(),0);
        vector<int> start_site(gas.size(),-1);


        for (int start = 0; start < n; ++start){
            tank_gas[start] = 0;
            for (int i = 0; i < n; ++i){
                int current_station = (start + i) % n;
                tank_gas[start] += gas[current_station] - cost[current_station];

                if(tank_gas[start]  < 0){
                    break;
                }
            }
            if(tank_gas[start] >= 0){
                start_site[start] = start;
            }
        }
        for(int i = 0; i <= gas.size() - 1; ++i){
            if(start_site[i] != -1){
                return start_site[i];
            }
        }
        return -1;
    }
};

```
```cpp
class Solution {
public:
    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {
        int total_left = 0;
        int curr_tank = 0;
        int starting_station = 0;
        
        for (int i = 0; i < gas.size(); ++i){
            total_left += gas[i] - cost[i];
            curr_tank += gas[i] - cost[i];

            if(curr_tank < 0){
                starting_station = i + 1;
                curr_tank = 0;
            }
        }
        return total_left >= 0 ? starting_station : -1;
    }
};

```


### 135. Candy
```cpp
class Solution {
public:
    int candy(vector<int>& ratings) {
        int length = ratings.size();
        vector<int> candies(length,1);

        for(int i = 1; i < length; ++i){
            if(ratings[i] > ratings[i-1]){
                candies[i] = candies[i - 1] + 1;
            }
        }

        for(int i = length - 2; i > -1; --i){
            if(ratings[i] > ratings[i+1]){
                candies[i] = max((candies[i + 1] + 1),candies[i]);
            }
        }

        return accumulate(candies.begin(),candies.end(),0);
    }
};
```



### 42. Trapping Rain Water

```cpp
//动态规划
class Solution {
public:
    int trap(vector<int>& height) {
        if(height.size() <= 2){return 0;}

        vector<int> left_max(height.size(),0);
        vector<int> right_max(height.size(),0);
        vector<int> water_height(height.size(),0);
        int total_water = 0;

        left_max[0] = height[0];
        for(int i = 1; i < height.size(); ++i){
            left_max[i] = max(left_max[i-1], height[i]);
        }

        right_max[height.size()-1] = height[height.size()-1];
        for(int i = height.size() - 2; i >= 0; --i){
            right_max[i] = max(right_max[i+1], height[i]);
        }

        for(int i = 1; i <= height.size()-2; ++ i){
            if (min(left_max[i],right_max[i]) - height[i] > 0){
                water_height[i] = min(left_max[i],right_max[i]) - height[i];
                total_water += water_height[i];
            }else{
                water_height[i] = 0;
            }
        }
        return total_water;
    }
};
```

```cpp
class Solution {
public:
    int trap(vector<int>& height) {
        int total_water = 0;
        int left = 0;
        int right = height.size() - 1;
        int left_max = 0;
        int right_max = 0;

        while(left < right){
            if (height[left] < height[right]){
                if(height[left]>=left_max){
                    left_max = height[left];
                }else{
                    total_water += left_max - height[left];
                }
                left++;
            }else{
                if(height[right] >= right_max){
                    right_max = height[right];
                }else{
                    total_water += right_max - height[right];
                }
                right--;
            }
        }

        return total_water;
    }
};
```



### 13. Roman to Integer
```cpp
class Solution {
public:
    int romanToInt(string s) {
        unordered_map<char, int> roman_to_int = {
            {'I',1},
            {'V',5},
            {'X',10},
            {'L',50},
            {'C',100},
            {'D',500},
            {'M',1000}
        };

        int total = 0;
        int prev_value = 0;

        for (char c:s){
            int current_value = roman_to_int[c];

            if(current_value>prev_value){
                total += current_value - 2 * prev_value;
            }else{
                total += current_value;
            }
            prev_value = current_value;
        }
        return total;
    }
};

```
### 12. Integer to Roman
```cpp
class Solution {
public:
    string intToRoman(int num) {
        vector<pair<int, string>> value_symbols = {
        {1000, "M"}, {900, "CM"}, {500, "D"}, {400, "CD"},
        {100, "C"}, {90, "XC"}, {50, "L"}, {40, "XL"},
        {10, "X"}, {9, "IX"}, {5, "V"}, {4, "IV"}, {1, "I"}
        };

        string result = "";

        for (const auto& [value, symbol] : value_symbols){
            while (num >= value){
                result += symbol;
                num -= value;
            }
        }
        return result;
    }
};

```


### 58. Length of Last Word
```cpp
class Solution {
public:
    int lengthOfLastWord(string s) {
        int n = s.size();
        int length = 0;

        int i = n - 1;
        while(i>=0&&s[i]==' '){
            i--;
        }
        while(i>=0&&s[i]!=' '){
            length++;
            i--;
        }
        return length;
    }
};
```


### 14. Longest Common Prefix
```cpp
class Solution {
public:
    string longestCommonPrefix(vector<string>& strs) {
        if(strs.empty()) return "";
        string prefix=strs[0];
        for(int i=1;i<strs.size();++i){
            while(strs[i].find(prefix)!=0){
            // 如果 prefix 是 strs[i] 的前缀，那么 strs[i].find(prefix) 应该返回 0，因为前缀必须从字符串的第一个字符开始匹配。
            // 如果 prefix 不是 strs[i] 的前缀，find 返回的值将不是 0，可能是因为：
            // prefix 在 strs[i] 中不存在（返回 std::string::npos）。
            // prefix 存在于 strs[i] 中，但不在开头（返回非零的索引）。
                prefix.pop_back();
                if(prefix.empty()) return "";
            }
        }
        return prefix;
    }
};
```

### 151. Reverse Words in a String
```cpp
class Solution {
public:
    string reverseWords(string s) {
        vector<string> words;
        string word;
        stringstream ss(s);
        while(ss>>word){
            words.push_back(word);
        }
        std::reverse(words.begin(),words.end());

        string result;
        for(int i=0;i<words.size();++i){
            result += words[i];
            if(i != words.size() - 1){
                result += " ";
            }
        }
        return result;
    }
};

```



### 6. Zigzag Conversion

```cpp
class Solution {
public:
    string convert(string s, int numRows) {
        if (numRows == 1 || s.size() <= numRows) return s;
        
        string result;
        result.reserve(s.size());  // 预先分配内存
        
        int cycleLen = 2 * numRows - 2;  // 每个周期的长度
        
        for (int i = 0; i < numRows; ++i) {
            for (int j = 0; i + j < s.size(); j += cycleLen) {
                result += s[i + j];  // 垂直方向的字符
                
                // 对于非首尾行，还需要添加斜向上的字符
                if (i != 0 && i != numRows - 1 && j + cycleLen - i < s.size()) {
                    result += s[j + cycleLen - i];
                }
            }
        }
        
        return result;
    }
};

```


### 28. Find the Index of the First Occurrence in a String
```cpp

class Solution {
public:
    int strStr(string haystack, string needle) {
        size_t pos = haystack.find(needle);
        return (pos != std::string::npos)?static_cast<int>(pos):-1;
    }
};

```
### 68. Text Justification
```cpp
using namespace std;

class Solution {
public:
    vector<string> fullJustify(vector<string>& words, int maxWidth) {
        vector<string> result;
        vector<string> line;
        int lineLength = 0;

        for (const string& word : words) {
            if (lineLength + word.size() + line.size() > maxWidth) {
                int totalSpaces = maxWidth - lineLength;
                int gaps = line.size() - 1;
                string formattedLine = line[0];
                
                if (gaps == 0) {
                    formattedLine += string(totalSpaces, ' ');
                } else {
                    int spacesPerGap = totalSpaces / gaps;
                    int extraSpaces = totalSpaces % gaps;
                    
                    for (int i = 1; i < line.size(); ++i) {
                        formattedLine += string(spacesPerGap + (i <= extraSpaces ? 1 : 0), ' ') + line[i];
                    }
                }
                result.push_back(formattedLine);
                line.clear();
                lineLength = 0;
            }
            line.push_back(word);
            lineLength += word.size();
        }

        string lastLine = "";
        for (int i = 0; i < line.size(); ++i) {
            lastLine += line[i] + (i < line.size() - 1 ? " " : "");
        }
        lastLine += string(maxWidth - lastLine.size(), ' ');
        result.push_back(lastLine);

        return result;
    }
};
```


### 125. Valid Palindrome

```cpp
class Solution {
public:
    bool isPalindrome(string s) {
        string cleaned = "";

        // // 自己实现is alphabetic or numeric函数
        // bool myIsalnum(char c) {
        //     return (c >= 'a' && c <= 'z') ||
        //            (c >= 'A' && c <= 'Z') ||
        //            (c >= '0' && c <= '9');
        // }
        
        // // 自己实现tolower函数
        // char myTolower(char c) {
        //     if (c >= 'A' && c <= 'Z') {
        //         return c - 'A' + 'a';
        //     }
        //     return c;
        // }

        for (char c : s){
            if (isalnum(c)){
                cleaned += tolower(c);
            }
        }
        int left = 0;
        int right = cleaned.length() - 1;

        while(left < right){
            if(cleaned[left]!=cleaned[right]){
                return false;
            }
            left++;
            right--;
        }
        return true;

    }
};

```



### 392. Is Subsequence

```cpp
//被隔开也是子串
class Solution {
public:
    bool isSubsequence(string s, string t) {
        if(s.empty())   return true;

        if(t.empty())   return false;

        int sIndex = 0;
        int sLen = s.length();

        for (char c : t){
            if (s[sIndex]==c){
                sIndex++;
                if (sIndex == sLen){
                    return true;
                }
            }
        }
        return false;
    }
};
```



### 167. Two Sum II - Input Array Is Sorted
```cpp
class Solution {
public:
    vector<int> twoSum(vector<int>& numbers, int target) {
        int left = 0;
        int right = numbers.size() - 1;
        while (left < right){
            int current_sum = numbers[left] + numbers[right];
            if (current_sum == target){
                return {left + 1, right + 1}; //索引从 1 开始
            }else if(current_sum < target){
                left ++;
            }else{
                right --;
            }
        }

        return {};
    }
};

```


### 11. Container With Most Water

```cpp

class Solution {
public:
    int maxArea(vector<int>& height) {
        int left = 0;
        int right = height.size() - 1;
        int maxArea = 0;

        while (left < right){
            int width = right - left;
            int minHeight = min(height[left], height[right]);

            int currentArea = width * minHeight;
            maxArea = max(maxArea, currentArea);
            if (height[left]<height[right]){
                left ++;
            }else{
                right --;
            }
        }
        return maxArea;
    }
};

```


### 15. 3Sum

```cpp
class Solution {
public:
    vector<vector<int>> threeSum(vector<int>& nums) {
        vector<vector<int>> result;
        if(nums.size()<3) return result;
        sort(nums.begin(),nums.end());
        for(int i=0;i<nums.size()-2;++i){
            if(i>0&&nums[i]==nums[i-1])continue;//跳过重复元素
            int left=i+1,right=nums.size()-1;
            while(left<right){
                int sum=nums[i]+nums[left]+nums[right];
                if(sum==0){
                    result.push_back({nums[i],nums[left],nums[right]});
                while(left<right&&nums[left]==nums[left+1])++left;//跳重
                while(left<right&&nums[right]==nums[right-1])--right;//跳重
                ++left;
                --right;
                }else if(sum<0){
                    ++left;
                }else{
                    --right;
                }
            }
        }
        return result;
    }
};

```

### 209. Minimum Size Subarray Sum
```cpp
class Solution {
public:
    int minSubArrayLen(int target, vector<int>& nums) {
        int n = nums.size();
        int left = 0;
        int current_sum = 0;
        int min_length = INT32_MAX;

        for (int right = 0; right < n; ++right){
            current_sum += nums[right];
            while(current_sum >= target){
                min_length = min(min_length, right - left + 1);
                current_sum -= nums[left];
                ++left;
            }
        }
        return min_length == INT32_MAX ? 0: min_length;
    }
};
```


### 3. Longest Substring Without Repeating Characters
<img width="505" alt="{A12D595C-751B-4A8F-9290-DA9458537C13}" src="https://github.com/user-attachments/assets/32a82ba6-2f92-4257-9d3a-e4337a28c9ab" />

```cpp

class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        vector<int> last_pos(256, -1); // 记录字符最后出现的位置
        int max_len = 0;
        int left = 0; // 滑动窗口的左边界
        for (int i = 0; i < s.size(); ++i) {
            char c = s[i];
            // 如果当前字符之前出现过且在窗口内，更新左边界
            if (last_pos[c] >= left) {
                left = last_pos[c] + 1;
            }
            last_pos[c] = i; // 更新当前字符的位置
            max_len = max(max_len, i - left + 1); // 计算当前窗口长度
        }
        return max_len;
    }
};
```

### 30. Substring with Concatenation of All Words
```cpp

using namespace std;

class Solution {
public:
    vector<int> findSubstring(string s, vector<string>& words) {
        vector<int> result; // 存储结果的起始索引
        if (s.empty() || words.empty()) return result;

        int word_len = words[0].size();       // 每个单词的长度
        int word_count = words.size();        // 单词总数
        int total_len = word_len * word_count; // 所有单词拼接后的总长度

        // 如果字符串长度小于总长度，直接返回空结果
        if (s.size() < total_len) return result;

        // 构建目标单词频率表
        unordered_map<string, int> target_map;
        for (const string& word : words) {
            target_map[word]++;
        }

        // 遍历字符串的每个可能起点（偏移量从 0 到 word_len - 1）
        for (int i = 0; i < word_len; ++i) {
            unordered_map<string, int> current_map; // 当前窗口的单词频率表
            int left = i, right = i, count = 0;     // 滑动窗口的左右边界和有效单词计数

            while (right + word_len <= s.size()) {
                // 提取当前单词
                string word = s.substr(right, word_len);
                right += word_len;

                if (target_map.find(word) != target_map.end()) {
                    // 如果当前单词在目标中，更新当前窗口的频率表
                    current_map[word]++;
                    count++;

                    // 如果某个单词出现次数过多，调整左边界
                    while (current_map[word] > target_map[word]) {
                        string left_word = s.substr(left, word_len);
                        current_map[left_word]--;
                        count--;
                        left += word_len;
                    }
                } else {
                    // 如果遇到不在目标中的单词，重置窗口
                    current_map.clear();
                    count = 0;
                    left = right;
                }

                // 如果窗口中的单词数量等于目标单词数量，记录起始索引
                if (count == word_count) {
                    result.push_back(left);

                    // 移动左边界，继续寻找下一个可能的子串
                    string left_word = s.substr(left, word_len);
                    current_map[left_word]--;
                    count--;
                    left += word_len;
                }
            }
        }

        return result;
    }
};

```
