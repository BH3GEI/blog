### 88. Merge Sorted Array
```python
class Solution:
    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:
        """
        Do not return anything, modify nums1 in-place instead.
        """
        # 两个数列各一指针
        i = m - 1
        j = n - 1
        # 用于写入的辅助指针
        k = m + n - 1

        while i >= 0 and j >= 0:
            if nums1[i] > nums2[j]:
                nums1[k] = nums1[i]
                i -= 1
            else:
                nums1[k] = nums2[j]
                j -= 1
            k -= 1
        
        # 如果nums1的有效长度短，nums2剩下的部分就直接覆盖前面那部分
        while j>= 0:
            nums1[k] = nums2[j]
            j -= 1
            k -= 1

        # 如果nums2的有效长度短，那到这已经完美不需要处理了
        
```

### 27. Remove Element
```python
class Solution:
    def removeElement(self, nums: List[int], val: int) -> int:
        k=0    # 慢指针
        # 很简单，就是利用双指针，有命中的时候辅助指针不自增，
        # 等着循环指针前移后，利用后面的前移步骤洗掉这个命中位置的元素
        for i in range(len(nums)):
            if nums[i] != val:
                if i != k:
                # 例：如果本身就是1357000，匹配2，那就没必要移动
                    nums[k] = nums[i]
                    # 把原本在后面的元素移到k的位置
                k += 1
        return k
```
```python
class Solution:
    def removeElement(self, nums: List[int], val: int) -> int:
        i = 0
        j = len(nums) - 1
        # 在某些情况下（例如数组中有很多等于 val 的元素）可能会更快，
        # 因为直接跳过了这些元素，而不需要逐一检查。
        # 但顺序会乱，因为尾部的元素被移动到了前面
        while i <= j:
            if nums[i] == val:
                nums[i] = nums[j]  # 用尾部元素替换
                j -= 1  # 尾部指针左移
            else:
                i += 1  # 头部指针右移
        
        return i
```
```python
class Solution:
    def removeElement(self, nums: List[int], val: int) -> int:
        # 使用列表推导式生成新数组
        filtered_nums = [x for x in nums if x != val]
        # 将结果写回原数组
        for i in range(len(filtered_nums)):
            nums[i] = filtered_nums[i]
        return len(filtered_nums)
```

### 26. Remove Duplicates from Sorted Array
```cpp
class Solution {
public:
    int removeDuplicates(vector<int>& nums) {
        if (nums.empty()) return 0; //判空

        int i = 0; //慢指针
        for (int j = 1; j < nums.size(); ++j){
            if (nums[j] != nums[i]){//若正常非重复，后面i会正常自增
                ++i;
                if (i != j){ //ij两个指针有错位时才进行赋值
                    nums[i] = nums[j]; 
                }
            }
        }
        return i + 1;
    }
};
```

### 80. Remove Duplicates from Sorted Array II
```cpp
class Solution {
public:
    int removeDuplicates(vector<int>& nums) {
        if (nums.size() <= 2) return  nums.size(); //数组长度小于等于2，直接返回长度
        int i = 2; //可以理解为慢指针，初始值为2（前两个元素一定符合条件）
        for(int j = 2; j < nums.size(); ++j){//从第3个元素开始遍历
            if (nums[j] != nums[i-2]){//如果当前元素与前两个不一样，就往前挪
                                      //如果一样，就不进来，让慢指针站着
                nums[i] = nums[j];  //挪
                i += 1;
            }
        }
        return i;
    }
};
```
```cpp
//一样，一些小更改
class Solution {
public:
    int removeDuplicates(vector<int>& nums) {
        if (nums.size() <= 2) return nums.size(); // 数组长度小于等于2，直接返回长度
        
        int i = 2; // 慢指针，初始值为2（前两个元素一定符合条件）
        int n = nums.size(); // 避免重复调用 nums.size()
        
        for (int j = 2; j < n; ++j) { // 从第3个元素开始遍历
            if (nums[j] != nums[i - 2]) { // 如果当前元素与前两个不一样
                nums[i++] = nums[j]; // 直接赋值并递增慢指针
            }
        }
        return i; // 返回符合条件的元素个数
    }
};
```
### 
