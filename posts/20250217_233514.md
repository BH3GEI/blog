### 88. Merge Sorted Array
```python
class Solution:
    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:
        """
        Do not return anything, modify nums1 in-place instead.
        """
        # 两个数列各一指针
        i = m - 1
        j = n - 1
        # 用于写入的辅助指针
        k = m + n - 1

        while i >= 0 and j >= 0:
            if nums1[i] > nums2[j]:
                nums1[k] = nums1[i]
                i -= 1
            else:
                nums1[k] = nums2[j]
                j -= 1
            k -= 1
        
        # 如果nums1的有效长度短，nums2剩下的部分就直接覆盖前面那部分
        while j>= 0:
            nums1[k] = nums2[j]
            j -= 1
            k -= 1

        # 如果nums2的有效长度短，那到这已经完美不需要处理了
        
```

```python
# 暴力解法
class Solution:
    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:
        """
        Do not return anything, modify nums1 in-place instead.
        """
        # 将 nums2 的元素直接复制到 nums1 的后半部分
        for i in range(n):
            nums1[m + i] = nums2[i]
        
        # 对整个 nums1 进行排序
        nums1.sort()
```

```cpp
//暴力解法
class Solution {
public:
    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {
        for (int i = 0; i < n; ++i) {
            nums1[i + m] = nums2[i];
        }
        std::sort(nums1.begin(), nums1.end()); //标准库函数，使用半开区间概念
    }
};

```

### 27. Remove Element
```python
class Solution:
    def removeElement(self, nums: List[int], val: int) -> int:
        k=0    # 慢指针
        # 很简单，就是利用双指针，有命中的时候辅助指针不自增，
        # 等着循环指针前移后，利用后面的前移步骤洗掉这个命中位置的元素
        for i in range(len(nums)):
            if nums[i] != val:
                if i != k:
                # 例：如果本身就是1357000，匹配2，那就没必要移动
                    nums[k] = nums[i]
                    # 把原本在后面的元素移到k的位置
                k += 1
        return k
```
```python
class Solution:
    def removeElement(self, nums: List[int], val: int) -> int:
        i = 0
        j = len(nums) - 1
        # 在某些情况下（例如数组中有很多等于 val 的元素）可能会更快，
        # 因为直接跳过了这些元素，而不需要逐一检查。
        # 但顺序会乱，因为尾部的元素被移动到了前面
        while i <= j:
            if nums[i] == val:
                nums[i] = nums[j]  # 用尾部元素替换
                j -= 1  # 尾部指针左移
            else:
                i += 1  # 头部指针右移
        
        return i
```
```python
class Solution:
    def removeElement(self, nums: List[int], val: int) -> int:
        # 使用列表推导式生成新数组
        filtered_nums = [x for x in nums if x != val]
        # 将结果写回原数组
        for i in range(len(filtered_nums)):
            nums[i] = filtered_nums[i]
        return len(filtered_nums)
```

```cpp
class Solution {
public:
    int removeElement(vector<int>& nums, int val) {
        std ::vector<int> temp; //temp arry
        for (int num : nums){
            if (num != val){
                temp.push_back(num);//or we can use push_front() in a std::<int> dq scenario
            }
        }
        nums = temp;
        return temp.size();
    }
};
```

### 26. Remove Duplicates from Sorted Array
```cpp
class Solution {
public:
    int removeDuplicates(vector<int>& nums) {
        if (nums.empty()) return 0; //判空

        int i = 0; //慢指针
        for (int j = 1; j < nums.size(); ++j){
            if (nums[j] != nums[i]){//若正常非重复，后面i会正常自增
                ++i;
                if (i != j){ //ij两个指针有错位时才进行赋值
                    nums[i] = nums[j]; 
                }
            }
        }
        return i + 1;
    }
};
```

```cpp
//暴力解法
class Solution {
public:
    int removeDuplicates(vector<int>& nums) {
        if(nums.empty()  )  return 0;
        
        vector<int> unique_nums;
        unique_nums.push_back(nums[0]);

        for (int i = 1; i < nums.size(); ++ i){
            if(nums[i] != unique_nums.back()){
                unique_nums.push_back(nums[i]);
            }
        }

        for (int i = 0; i < unique_nums.size(); ++i){
            nums [i] = 0;
        }

        for (int i = 0; i < unique_nums.size(); ++i){
            nums [i] = unique_nums[i];
        }

        return unique_nums.size();
    }
};

```

### 80. Remove Duplicates from Sorted Array II
```cpp
class Solution {
public:
    int removeDuplicates(vector<int>& nums) {
        if (nums.size() <= 2) return  nums.size(); //数组长度小于等于2，直接返回长度
        int i = 2; //可以理解为慢指针，初始值为2（前两个元素一定符合条件）
        for(int j = 2; j < nums.size(); ++j){//从第3个元素开始遍历
            if (nums[j] != nums[i-2]){//如果当前元素与前两个不一样，就往前挪
                                      //如果一样，就不进来，让慢指针站着
                nums[i] = nums[j];  //挪
                i += 1;
            }
        }
        return i;
    }
};
```
```cpp
//一样，一些小更改
class Solution {
public:
    int removeDuplicates(vector<int>& nums) {
        if (nums.size() <= 2) return nums.size(); // 数组长度小于等于2，直接返回长度
        
        int i = 2; // 慢指针，初始值为2（前两个元素一定符合条件）
        int n = nums.size(); // 避免重复调用 nums.size()
        
        for (int j = 2; j < n; ++j) { // 从第3个元素开始遍历
            if (nums[j] != nums[i - 2]) { // 如果当前元素与前两个不一样
                nums[i++] = nums[j]; // 直接赋值并递增慢指针
            }
        }
        return i; // 返回符合条件的元素个数
    }
};
```

```cpp
//暴力解法
class Solution {
public:
    int removeDuplicates(vector<int>& nums) {
        int size = nums.size();
        vector<int> temp;

        if (size <= 2) return size;

        temp.push_back(nums[0]);
        temp.push_back(nums[1]);

        for(int i = 2; i < size; ++i){
            if(nums[i] != temp[temp.size()-2]){
                temp.push_back(nums[i]);
            }
        }
        for(int i = 0; i < temp.size(); ++i){
            nums[i] = temp[i];
        }
        return temp.size();
    }
};

```

### 169. Majority Element
```cpp
class Solution {
public:
    int majorityElement(vector<int>& nums) {
        //用摩尔投票算法（抵消机制）
        int candidate = 0;
        int count = 0;
        for (int num : nums) {
            if （count == 0) {
                candidate = num;
            }
            count += (num == candidate) ? 1: -1;
        }
        return candidate;
        //同+异-，到0就换人，最后没被-到0的就是正确candidate
    }
};

```

```cpp
//暴力解法
class Solution {
public:
    int majorityElement(vector<int>& nums) {
        int size = nums.size();
        for(int num : nums){
            int count = 0;
            for (int other : nums){
                if(num == other){
                    ++count;
                }
            }
            if(count> size/2){
                return num;
            }
        }
        return -1;
    }
};
```

### 189. Rotate Array
<img width="241" alt="{82C08DFF-EE2C-44CA-BC51-9CF36696EEB6}" src="https://github.com/user-attachments/assets/9b6ed2ae-c6d6-43e3-9ee5-3b3eb28ed7bf" />

<img width="241" alt="{4F6C9CBF-38CD-47C7-AD21-0371340FCA83}" src="https://github.com/user-attachments/assets/3c15ce2a-3fa3-47ea-b8f6-0c98c425788a" />

<img width="483" alt="{55730CE6-D344-4739-8F8C-784572E7160F}" src="https://github.com/user-attachments/assets/0986152a-423b-4962-a530-7b6d028053a3" />


#### 示例：
假设我们有一个数组 `nums = [1, 2, 3, 4, 5, 6]`，并且 `k = 2`。我们的目标是将数组向右旋转 2 个位置。

##### 初始数组：
```
[1, 2, 3, 4, 5, 6]
```

##### 旋转后的目标数组：
```
[5, 6, 1, 2, 3, 4]
```

#### 算法执行过程：

##### 第一步：初始化
- 数组长度 `n = 6`。
- `k = k % n = 2 % 6 = 2`。
- 定义计数器 `count = 0`，用于记录已经处理过的元素数量。
- 外层循环从 `start = 0` 开始。

##### 第二步：处理第一个环
1. **外层循环**：`start = 0`，表示从索引 `0` 开始处理。
   - `current = start = 0`，`prev = nums[0] = 1`。
   
2. **内层循环**（`do-while`）：
   - **第一次迭代**：
     - 计算下一个位置：`next = (current + k) % n = (0 + 2) % 6 = 2`。
     - 保存目标位置的值：`temp = nums[next] = nums[2] = 3`。
     - 将当前值放到目标位置：`nums[next] = prev = 1`。
     - 更新 `prev = temp = 3`。
     - 更新 `current = next = 2`。
     - 增加计数器：`count++`，现在 `count = 1`。
     
     当前数组状态：
     ```
     [1, 2, 1, 4, 5, 6]
     ```

   - **第二次迭代**：
     - 计算下一个位置：`next = (current + k) % n = (2 + 2) % 6 = 4`。
     - 保存目标位置的值：`temp = nums[next] = nums[4] = 5`。
     - 将当前值放到目标位置：`nums[next] = prev = 3`。
     - 更新 `prev = temp = 5`。
     - 更新 `current = next = 4`。
     - 增加计数器：`count++`，现在 `count = 2`。
     
     当前数组状态：
     ```
     [1, 2, 1, 4, 3, 6]
     ```

   - **第三次迭代**：
     - 计算下一个位置：`next = (current + k) % n = (4 + 2) % 6 = 0`。
     - 保存目标位置的值：`temp = nums[next] = nums[0] = 1`。
     - 将当前值放到目标位置：`nums[next] = prev = 5`。
     - 更新 `prev = temp = 1`。
     - 更新 `current = next = 0`。
     - 增加计数器：`count++`，现在 `count = 3`。
     
     当前数组状态：
     ```
     [5, 2, 1, 4, 3, 6]
     ```

   - **退出内层循环**：此时 `current == start`，即回到了起始位置 `0`，表示这个环已经处理完毕。

##### 第三步：处理第二个环
1. **外层循环**：`start = 1`，表示从索引 `1` 开始处理。
   - `current = start = 1`，`prev = nums[1] = 2`。

2. **内层循环**（`do-while`）：
   - **第一次迭代**：
     - 计算下一个位置：`next = (current + k) % n = (1 + 2) % 6 = 3`。
     - 保存目标位置的值：`temp = nums[next] = nums[3] = 4`。
     - 将当前值放到目标位置：`nums[next] = prev = 2`。
     - 更新 `prev = temp = 4`。
     - 更新 `current = next = 3`。
     - 增加计数器：`count++`，现在 `count = 4`。
     
     当前数组状态：
     ```
     [5, 2, 1, 2, 3, 6]
     ```

   - **第二次迭代**：
     - 计算下一个位置：`next = (current + k) % n = (3 + 2) % 6 = 5`。
     - 保存目标位置的值：`temp = nums[next] = nums[5] = 6`。
     - 将当前值放到目标位置：`nums[next] = prev = 4`。
     - 更新 `prev = temp = 6`。
     - 更新 `current = next = 5`。
     - 增加计数器：`count++`，现在 `count = 5`。
     
     当前数组状态：
     ```
     [5, 2, 1, 2, 3, 4]
     ```

   - **第三次迭代**：
     - 计算下一个位置：`next = (current + k) % n = (5 + 2) % 6 = 1`。
     - 保存目标位置的值：`temp = nums[next] = nums[1] = 2`。
     - 将当前值放到目标位置：`nums[next] = prev = 6`。
     - 更新 `prev = temp = 2`。
     - 更新 `current = next = 1`。
     - 增加计数器：`count++`，现在 `count = 6`。
     
     当前数组状态：
     ```
     [5, 6, 1, 2, 3, 4]
     ```

   - **退出内层循环**：此时 `current == start`，即回到了起始位置 `1`，表示这个环已经处理完毕。

##### 第四步：结束
- 此时 `count == n`，所有元素都已经被处理完毕，算法结束。

#### 最终结果：
```
[5, 6, 1, 2, 3, 4]
```

#### 总结：
在这个例子中，数组被分成了两个环：
1. 第一个环：`1 -> 3 -> 5 -> 1`。
2. 第二个环：`2 -> 4 -> 6 -> 2`。

外层循环负责确保每个环都被处理，而内层循环则在一个环内完成元素的旋转。通过这种方式，算法高效地完成了数组的旋转操作。
```cpp
class Solution {
public:
    void rotate(vector<int>& nums, int k) {
        int n = nums.size(); //
        k = k % n;
        int count = 0; //当 count 达到数组的长度 n 时，说明所有元素都已经完成了旋转。
        for (int start = 0; count < n; ++start){
            int current =start; //当前正在处理的元素的索引
            int prev =nums[start]; //当前元素的值

            do{
                int next = (current + k) % n; //计算当前元素应该移动到的目标位置。
                int temp = nums[next]; //保存目标位置的原始值。
                nums[next]=prev; //将当前元素的值放到目标位置。
                prev = temp; //更新 prev 为刚才保存的目标位置的原始值，以便下一次循环使用。
                current = next; //更新 current 为下一个要处理的索引。
                count++;
            }while(start != current); //当 current 回到起始位置 start 时，表示这个“环”内的所有元素都已经被处理完
        }
    }
};
```

```cpp
class Solution {
public:
    void rotate(vector<int>& nums, int k) {
        int n = nums.size();
        k = k % n;
        reverse(nums.begin(),nums.end());
        reverse(nums.begin(),nums.begin()+k);
        reverse(nums.begin()+k,nums.end());
    }
};
```
```cpp

//暴力
class Solution {
public:
    void rotate(vector<int>& nums, int k) {
        int size = nums.size();
        int step = k % size;
        vector<int> front_nums(step);
        vector<int> back_nums(size-step);
        for(int i=0; i<step; ++i){
            front_nums[i]=nums[size-step+i];
        }
        for(int i=0; i<size-step; ++i){
            back_nums[i]=nums[i];
        }
        for(int i=0; i<size; ++i){
            if(i<step){
                nums[i]=front_nums[i];
            }
            else{
                nums[i]=back_nums[i-step];
            }
        }
    }
};
```

### 121. Best Time to Buy and Sell Stock

```cpp
//暴力
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int size = prices.size();
        int profit = 0;
        for(int i = 0; i < size; ++i){
            int buy = prices[i];
            for(int j = i + 1; j < size; ++j){
                int sell = prices[j];
                if((sell - buy)>profit){
                    profit = sell - buy;
                }
            }
        }
        return profit;
    }
};
```
```cpp
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int buy = INT_MAX;
        int profit = 0;
        for (int price : prices){
            if (price < buy){
                buy = price;
            }
            else{
                profit = max(profit, price - buy);
            }
        }
        return profit;
    }

};

```

```cpp
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int size = prices.size();
        if (size <= 1) return 0;

        int min_price = INT_MAX;
        int profit = 0; 

        for (int i = 1; i < size; ++i) {
            min_price = min(prices[i-1],min_price);
            profit = max(prices[i] - min_price, profit);
        }

        return profit;
    }
};

```
