### 1. Two Sum
```cpp
#include <vector>

class Solution {
public:
    /**
     * @brief 找到数组中两个数的索引，使它们的和等于目标值（暴力解法）。
     * 
     * @param nums 输入的整数数组
     * @param target 目标和
     * @return vector<int> 返回两个数的索引
     */
    std::vector<int> twoSum(std::vector<int>& nums, int target) {
        // 双重循环遍历所有可能的数字对
        for (int i = 0; i < nums.size(); ++i) {
            for (int j = i + 1; j < nums.size(); ++j) { // 注意：j 从 i+1 开始，避免重复使用同一个元素
                if (nums[i] + nums[j] == target) {
                    return {i, j}; // 如果找到符合条件的两个数，直接返回它们的索引
                }
            }
        }

        // 如果没有找到符合条件的两个数，返回空数组
        return {};
    }
};
```
```cpp
#include <vector>
#include <unordered_map>

class Solution {
public:
    /**
     * @brief 找到数组中两个数的索引，使它们的和等于目标值。
     * 
     * @param nums 输入的整数数组
     * @param target 目标和
     * @return vector<int> 返回两个数的索引
     */
    std::vector<int> twoSum(std::vector<int>& nums, int target) {
        // 使用哈希表存储已经遍历过的数字及其索引
        std::unordered_map<int, int> num_map;

        // 遍历数组
        for (int i = 0; i < nums.size(); ++i) {
            int complement = target - nums[i]; // 计算当前数字的补数

            // 检查补数是否已经在哈希表中
            if (num_map.find(complement) != num_map.end()) {
                // 如果找到补数，返回补数的索引和当前索引
                return {num_map[complement], i};
            }

            // 将当前数字及其索引存入哈希表
            num_map[nums[i]] = i;
        }

        // 如果没有找到符合条件的两个数，返回空数组
        return {};
    }
};
```

### 2. Add Two Numbers
```cpp

/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */

class Solution {
public:
    // 辅助函数：将链表转换为整数（链表头是数字的个位，即逆序存储）
    long long listToNumber(ListNode* head) {
        long long num = 0;
        int multiplier = 1; // 从个位开始，每次乘以10向高位移动
        while (head) {
            num += head->val * multiplier; // 将当前位的值乘以权重后累加
            multiplier *= 10;             // 权重升级到更高位（十位、百位...）
            head = head->next;             // 移动到下一个节点
        }
        return num;
    }

    // 辅助函数：将整数转换为逆序链表（例如123转换为3->2->1）
    ListNode* numberToList(long long num) {
        if (num == 0) return new ListNode(0); // 处理结果为0的特殊情况
        ListNode* dummy = new ListNode();      // 虚拟头节点，简化链表操作
        ListNode* curr = dummy;
        while (num > 0) {
            int digit = num % 10;  // 取出当前最低位（例如123 % 10 = 3）
            curr->next = new ListNode(digit); // 创建新节点存储该位
            curr = curr->next;     // 移动指针到新节点
            num /= 10;             // 去掉已处理的最低位（例如123 → 12）
        }
        return dummy->next;        // 返回实际链表的头节点
    }

    // 主函数：暴力解法（注意：当数字极大时可能导致long long溢出！）
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
        // 1. 将两个链表转换为整数
        long long num1 = listToNumber(l1);
        long long num2 = listToNumber(l2);
        // 2. 直接相加得到结果
        long long sum = num1 + num2;
        // 3. 将结果转换回逆序链表
        return numberToList(sum);
    }
};

```
```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */

class Solution {
public:
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
        // 创建虚拟头节点，简化链表操作（避免处理头节点特殊情况）
        ListNode* dummy = new ListNode();
        ListNode* curr = dummy; // curr用于构建新链表
        int carry = 0;          // 进位值，初始为0
        
        // 循环条件：l1未遍历完 或 l2未遍历完 或 还有进位未处理
        while (l1 || l2 || carry) {
            // 1. 获取当前位的值（如果链表已结束，则补0）
            int val1 = l1 ? l1->val : 0;
            int val2 = l2 ? l2->val : 0;
            
            // 2. 计算当前位的和（加上进位）
            int sum = val1 + val2 + carry;
            
            // 3. 更新进位（例如sum=15，则carry=1）
            carry = sum / 10;
            
            // 4. 创建新节点存储当前位的值（取个位，例如15 → 5）
            curr->next = new ListNode(sum % 10);
            curr = curr->next; // 移动curr到新节点
            
            // 5. 移动链表指针（如果未到末尾）
            if (l1) l1 = l1->next;
            if (l2) l2 = l2->next;
        }
        
        // 返回实际头节点（dummy的下一个节点）
        return dummy->next;
    }
};
```
