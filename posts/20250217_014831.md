### 1. Two Sum
```cpp
#include <vector>

class Solution {
public:
    /**
     * @brief 找到数组中两个数的索引，使它们的和等于目标值（暴力解法）。
     * 
     * @param nums 输入的整数数组
     * @param target 目标和
     * @return vector<int> 返回两个数的索引
     */
    std::vector<int> twoSum(std::vector<int>& nums, int target) {
        // 双重循环遍历所有可能的数字对
        for (int i = 0; i < nums.size(); ++i) {
            for (int j = i + 1; j < nums.size(); ++j) { // 注意：j 从 i+1 开始，避免重复使用同一个元素
                if (nums[i] + nums[j] == target) {
                    return {i, j}; // 如果找到符合条件的两个数，直接返回它们的索引
                }
            }
        }

        // 如果没有找到符合条件的两个数，返回空数组
        return {};
    }
};
```
```cpp
#include <vector>
#include <unordered_map>

class Solution {
public:
    /**
     * @brief 找到数组中两个数的索引，使它们的和等于目标值。
     * 
     * @param nums 输入的整数数组
     * @param target 目标和
     * @return vector<int> 返回两个数的索引
     */
    std::vector<int> twoSum(std::vector<int>& nums, int target) {
        // 使用哈希表存储已经遍历过的数字及其索引
        std::unordered_map<int, int> num_map;

        // 遍历数组
        for (int i = 0; i < nums.size(); ++i) {
            int complement = target - nums[i]; // 计算当前数字的补数

            // 检查补数是否已经在哈希表中
            if (num_map.find(complement) != num_map.end()) {
                // 如果找到补数，返回补数的索引和当前索引
                return {num_map[complement], i};
            }

            // 将当前数字及其索引存入哈希表
            num_map[nums[i]] = i;
        }

        // 如果没有找到符合条件的两个数，返回空数组
        return {};
    }
};
```
